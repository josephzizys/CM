<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1"/>
<style type="text/css" media="all">
@import "../css/cm.css";
</style>
<title>receive</title>
</head>

<body>
<div id="content"> 
<!-- begin content -->
<dl class="dictsyntax">
<dt>[Function]</dt>
<dd><code>(</code><code class="entry">receive</code> <var>hook</var> <var>stream</var> {<var>keyword</var> <var>value</var>}*<code>)</code></dd>
</dl>

<p>
Establishes <var>hook</var> to continuously receive data
from <var>stream</var> as soon as data arrives from an external source
or application. Returns no values. Both the calling syntax
of <var>hook</var> and any keyword arguments to the function depend on
the type of <var>stream</var>.  The receive hook remains in effect
until cancelled by calling <code>receive</code> again with a null
hook.
</p>

<p>
From the the callers perspective the <var>hook</var> seems to receive
data asyncronouosly since the Lisp REPL is not blocked while receiving
is in effect. From Lisp's perspective, receive almost always polling
in some manner. How this polling is implemeneted (or if it is
implemented at all) depends on the host Lisp and operating
system. CM employ three basic strategies to achive this effect:
</p>


<ul>
<li>
Threaded polling: the host Lisp either provides native threads (true
OS threads) or threads implemented inside Lisp. Both version allow
multiple receive sessions to occur simultaneously but native threads
are much faster and much more responsive than Lisp based threads.
</li>

<li>
Periodic polling: the host Lisp provides the ability to periodically
call a function. This periodic evaluation runs in the main Lisp
process but does not block the REPL. Only one polling function can be
set at a time.
</li>

<li>
Callbacks. The host lisp provides the ability for an external
application (such as GTK or Midishare) to call Lisp functions
asynchronously from another process.
</li>

</ul>

Because multiprocessing is not addressed by the Common Lisp standard
and is only an optional add-on in Scheme (SRFI-18), there are
important differences in how receive works across the various Lisp
implementations and operating systems. These implementation details
are important to know because they determine how useful receive will
be as an interactive tool (or even if it can be used at all).  Here is
a summary of receiving strategies are available as of this writing
(July '05):
</p>

<div class="float" >
<p class="captxt">
<span class="floatlabel">Table 1.</span> Implementation of receiving
strategies in supported Lisp implementations: LT (Lisp threads) NT
(native threads) PP (periodic polling).
</p>

<table class="float">
<tr >
<td>&nbsp;</td>
<th class="col" align="center" style="padding-left:2em;padding-right:2em;">Linux</th>
<th class="col" align="center" style="padding-left:2empadding-right:2em;">OS X</th>
<th class="col" align="center" style="padding-left:2em;padding-right:2em;">Windows</th>
</tr>
<tr><th="row">CMUCL</th>    <td align="center">LT, PP</td><td align="center">PP</td><td></td></tr>
<tr><th="row">Gauche</th>   <td align="center">NT    </td><td align="center">NT</td><td></td></tr>
<tr><th="row">LispWorks</th><td align="center">LT   </td><td align="center">NT</td><td align="center">NT</td></tr>
<tr><th="row">OpenMCL</th>  <td align="center">NT, PP</td><td align="center">NT, PP</td><td></td></tr>
<tr><th="row">SBCL</th>     <td align="center">NT<span style="font-size:smaller;vertical-align:super"> 1</span>, PP   </td><td align="center">PP</td><td></td></tr>
</table>

<p style="font-style:normal;font-size:smaller;">
<span style="vertical-align:super;">1</span>  Native threads are in alpha release.<br/>
</p>


</div>



<!--
<p id="args"><code class="entry">foo</code> supports the following [slot initializations:] [keyword arguments:]
</p>

<dl>

<dt>
<code class="keyword">:bar</code> <var>number</var>
</dt>
<dd>Blah, defaults to zuz.</dd>

<dt>
<code class="keyword">:baz</code> {<var>list</var> | <var>false</var>}
</dt>
<dd>asdf</dd>

</dl>
-->
<h4>Examples:</h4>
<div class="float">
<p class="captxt">
<span class="floatlabel">Example 1.</span> Receiving in input from
Portmidi. You need an external MIDI keyboard to perform these
examples.
</p>
<pre class="code">
(defparameter pm 
  (portmidi-open :input 1 :output 3 :latency 0))

(receive (lambda (mm ms) mm ms) pm)

(receive? pm)

;;; midi through

(receive (lambda (mm ms) (write-event mm pm ms)) pm)

(receive #f pm)

;;; midi trace

(receive (lambda (mm ms) (midi-print-message mm ms) (force-output)) pm)

(receive #f pm)

;;; harmonizer

(receive
  (lambda (mm ms)
    (when (or (note-on-p mm)
              (note-off-p mm))
      (let ((k (note-on-key mm)))
        (write-event mm pm ms)
        (write-event (midi-copy-message mm :data1 (+ k 3)) pm ms)
        (write-event (midi-copy-message mm :data1 (+ k 7)) pm ms))))
  pm)

(receive #f pm)

(portmidi-close)

;;; random bursts using future scheduling with small latency

(defparameter pm 
  (portmidi-open :input 1 :output 3 :latency 10))

(receive (lambda (mm ms)
           (when (note-on-p mm)
             (let ((burst (list (note-on-key mm))))
               (loop repeat 5 for k = (between 10 120 k)
                  do (push k burst))
               (dolist (b burst)
                 (write-event (midi-copy-message mm :data1 b)
                              pm 0))
               (dolist (b burst)
                 (write-event (midi-copy-message mm :data1 b :data2 0)
                              pm (+ ms 200))))))
         pm)

(receive #f pm)
(receive? pm)
(portmidi-close  )



</pre>
</div>
<h4>See also:</h4>
<ul>
<li><a href="foo.html"><code>foo</code></a> [Function]</li>
<li><a href="bar.html">Bar</a> [Topic]</li>
</ul>

</div> <!-- end content -->
<hr class="inv"/>
<!-- Footer -->
<div id="footer">
<div id="version">$Name$</div>
<div id="cvs-info">($Revision$, $Date$)</div>
</div>
</body>
</html>
