<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1"/>
<style type="text/css" media="all">
@import "../css/cm.css";
</style>
<title>receive</title>
</head>

<body>
<div id="content"> 
<!-- begin content -->
<dl class="dictsyntax">
<dt>[Function]</dt>
<dd><code>(</code><code class="entry">receive</code> <var>hook</var> <var>stream</var> {<var>keyword</var> <var>value</var>}*<code>)</code></dd>
</dl>

<p>
Installs <var>hook</var> to continuously receive data
from <var>stream</var> as soon as data arrives from an external source
or application. Returns no values. Both the calling syntax
of <var>hook</var> and the availability of keyword arguments depend on
the type of <var>stream</var>.  Receiving remains in effect
until cancelled by calling the function again with a null hook.
</p>

<p>
From the caller's perspective <var>hook</var> seems to receive data
asyncronouosly since the Lisp REPL is not blocked during
receiving. From Lisp's perspective receive is almost always polling
in some manner: how this polling is implemeneted (or if it is
implemented at all) depends on the host Lisp and operating system.

CM utilizes three possible strategies for implementing non-blocking
receivingl which strategies are available depends on the Lisp/OS
combination.
</p>


<ul>
<li>
Threaded polling: the host Lisp either provides native threads (true
OS threads) or threads implemented in Lisp. Both allow multiple
receive sessions to run simultaneously but native threads are much
faster and responsive than Lisp threads.
</li>

<li>
Periodic polling: the host Lisp provides the ability to periodically
call a function in the main Lisp process but without blocking the
REPL. Only one polling function can be in effect at a time.  The
length of time between task execution can be less than a millisecond
and is configurable by the user at receive time.
</li>

<li>
Callbacks: the host lisp provides the ability for an external
application such as GTK or Midishare to call Lisp functions
asynchronously from a different OS process.
</li>
</ul>

<p>
Because multiprocessing is not part of the Common Lisp standard and is
only optional in Scheme
(see <a href="http://srfi.schemers.org/srfi-18/">SRFI-18</a>), there
are differences in how -- and how well -- receiving works in the
various Lisp/OS combinations. Here is a summary of the various
strategies that are available as of this writing (July '05):
</p>

<div class="float" >
<p class="captxt">
<span class="floatlabel">Table 1.</span> Implementation of receiving
strategies in supported Lisp implementations: LT (Lisp threads) NT
(native threads) PP (periodic polling).
</p>

<table class="float">
<tr >
<td>&nbsp;</td>
<th class="col" align="center" style="padding-left:2em;padding-right:2em;">Linux</th>
<th class="col" align="center" style="padding-left:2empadding-right:2em;">OS X</th>
<th class="col" align="center" style="padding-left:2em;padding-right:2em;">Windows</th>
</tr>
<tr><td style="font-weight:bold;">CMUCL</td>    <td align="center">LT, PP</td><td align="center">PP</td><td></td></tr>
<tr><td style="font-weight:bold;">Gauche</td>   <td align="center">NT    </td><td align="center">NT</td><td></td></tr>
<tr><td style="font-weight:bold;">LispWorks</td><td align="center">LT   </td><td align="center">NT</td><td align="center">NT</td></tr>
<tr><td style="font-weight:bold;">OpenMCL</td>  <td align="center">NT, PP</td><td align="center">NT, PP</td><td></td></tr>
<tr><td style="font-weight:bold;">SBCL</td>     <td align="center">NT<span style="font-size:smaller;vertical-align:super"> 1</span>, PP   </td><td align="center">PP</td><td></td></tr>
</table>

<p style="font-style:normal;font-size:smaller;">
<span style="vertical-align:super;">1</span>  Native threads are in alpha release.<br/>
</p>


</div>



<!--
<p id="args"><code class="entry">foo</code> supports the following [slot initializations:] [keyword arguments:]
</p>

<dl>

<dt>
<code class="keyword">:bar</code> <var>number</var>
</dt>
<dd>Blah, defaults to zuz.</dd>

<dt>
<code class="keyword">:baz</code> {<var>list</var> | <var>false</var>}
</dt>
<dd>asdf</dd>

</dl>
-->
<h4>Examples:</h4>
<div class="float">
<p class="captxt">
<span class="floatlabel">Example 1.</span> Receiving interactive input from
Portmidi. You need an external MIDI keyboard to perform these
examples.
</p>
<pre class="code">
;;; first open a valid Portmidi input and output pair

(defparameter pm 
  (portmidi-open :input 1 :output 3 :latency 0))

;;; a midi through

(receive (lambda (mm ms) (write-event mm pm ms)) pm)

;;; play your keyboard for awhile...then

(receive #f pm)

;;; a midi trace. you may need a (force-output) after the print
;;; statement to see the results in some Lisps

(define (miditrace mm ms)
  (write-event mm pm ms)
  (midi-print-message mm ms)
  (force-output))

(receive #'miditrace pm)

;;; play your keyboard for awhile...then

(receive #f pm)

;;; make a harmonizer

(receive
  (lambda (mm ms)
    (when (or (note-on-p mm)
              (note-off-p mm))
      (let ((k (note-on-key mm)))
        (write-event mm pm ms)
        (write-event (midi-copy-message mm :data1 (+ k 3)) pm ms)
        (write-event (midi-copy-message mm :data1 (+ k 7)) pm ms))))
  pm)

;;; play your keyboard for awhile...then

(receive #f pm)

(portmidi-close)

;;; sending random bursts using future scheduling for noteOffs. future
;;; scheduling is enabled in Portmidi by specifing :latency>0.  This
;;; uses a latency of only 10ms so it sounds like realtime.

(defparameter pm 
  (portmidi-open :input 1 :output 3 :latency 10))

(receive (lambda (mm ms)
           (when (note-on-p mm)
             (let ((burst (list (note-on-key mm))))
               (loop repeat 5 for k = (between 10 120 k)
                  do (push k burst))
               (dolist (b burst)
                 (write-event (midi-copy-message mm :data1 b)
                              pm 0))
               (dolist (b burst)
                 (write-event (midi-copy-message mm :data1 b :data2 0)
                              pm (+ ms 200))))))
         pm)


;;; play single notes on your keyboard for awhile...then

(receive #f pm)

(portmidi-close  )
</pre>
</div>
<h4>See also:</h4>
<ul>
<li><a href="foo.html"><code>foo</code></a> [Function]</li>
<li><a href="bar.html">Bar</a> [Topic]</li>
</ul>

</div> <!-- end content -->
<hr class="inv"/>
<!-- Footer -->
<div id="footer">
<div id="version">$Name$</div>
<div id="cvs-info">($Revision$, $Date$)</div>
</div>
</body>
</html>
