<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1"/>
<style type="text/css" media="all">
@import "../css/cm.css";
</style>
<title>rts</title>
</head>

<body>
<div id="content"> <!-- begin content -->
<dl class="dictsyntax">
<dt>[Function]</dt>
<dd><code>(</code><code class="entry">rts</code> [<var>objects</var>] [<var>to</var>] [<var>start</var>] [<var>end</var>] <code>)</code></dd>
</dl>

<p>
Starts the "real time" scheduler according to optional
arguments. Returns no values.
</p>

<p id="args"><code class="entry">rts</code> supports the following optional arguments:
</p>

<dl>

<dt>
<var>objects</var> {<var>objects</var> | <var>false</var>}
</dt>
<dd>
An optional object or list of objects to place in the scheduling
queue. If the value is false then the scheduler starts running with no
pending objects. While the scheduler is running objects can always be
added "interactively" by calling <a href="sprout-fn.html">sprout</a>
from the REPL or from an active
<a href="set-receiver-fn.html">receiver hook</a>.
</dd>
<dt>
<var>to</var> {<var>stream</var> | <var>false</var>}
</dt>
<dd>An optional destination output stream, defaults
to <a
href="current-output-stream-fn.html">current-output-stream</a>. If the
value is a stream then it must already be open and initialized.  If
the value is false then no output stream is assumed and the caller is
expected to manage stream IO themselves.
</dd>
<dt><var>ahead</var> <var>number</var>
<dd>An optional start time offset, defaults to 0.<dd>
<dt><var>end</var> {<var>number</var> | <var>boolean</var>}
<dd>
If <var>end</var> is a number then <code>rts</code> stops running when
that time has been reached in the score or when no objects remain
pending in the scheduler, whichever comes first.  If <var>end</var>
is boolean true then <code>rts</code> stops running when no more
objects are pending. If <var>end</var> is false then rts will run
(even if the queue is empty)
until <a href="rts-stop-fn.html">rts-stop</a> is called to terminate
scheduling. The default value is boolean true if <var>objects</var>
are specified else boolean false.
</dd>
</dl>

<p>

<code>rts</code> and <a href="events-fn.html">events</a> are "source
compatible" scheduling environments, meaning
<a href="process-mac.html">process</a> definitions do not have to be
modified to run in either environment, and scheduling functions such
as <a href="now-fn.html">now</a>, <a href="output-fn.html">output</a>
and <a href="sprout-fn.html">sprout</a> behave identically in both
schedulers.  The most important differences between the two schedulers
are:<!-- <code>rts</code> and <a href="events-fn.html">events</a>
(aside from the obvious real time scheduling aspect) are: -->

<ul>
<li>the REPL is not blocked by <code>rts</code> while the scheduler is
running.
</li>
<li><code>rts</code> can be started without objects and,
if <var>end</var> is false, <code>rts</code> will continue to run
until it is explicitly stopped, even if its queue is empty.
</li>
<li> <a href="sprout-fn.html">sprout</a> can be called from the REPL
or a <a href="receive-fn.html">receive</a> hook to add objects
to <code>rts</code> "interactively", as long as <code>rts</code> is
running.
</li>
<li>The values returned by <a href="now-fn.html">now</a> reflect the
current real time in seconds.</li>
</ul>

<p>
Although process definitions do not have to be changed to run under
<code>rts</code>, real time scheduling does place timing demands on
software that non-real time scheduling does not. Process definitions
should avoid consing and creating lots of temporary structure or being
otherwise wasteful and inefficient.  Consider reusing events rather
than creating new one for each output statement.  If you are working
with MIDI, consider using low-level,
consless <a href="midi-topic.html#midi_messages">MIDI messages</a> in
place of <a href="midi-cls.html">midi</a> objects.
</p>

<h4>Implementation:</h4>

<p>
CM uses either native threads or a 1 millisecond periodic task to
implement <code>rts</code>. The availability of either method depends
on the underlying Lisp implementation:
</p>

<div class="float" >
<p class="captxt">
<span class="floatlabel">Table 1.</span> Implementation
of <code>rts</code> scheduling in the supported Lisp implementations
(most current release).  NT=native threads, PP=periodic polling.
</p>

<table class="float">
<tr >
<td>&nbsp;</td>
<th class="col" align="center" style="padding-left:2em;padding-right:2em;">Linux</th>
<th class="col" align="center" style="padding-left:2empadding-right:2em;">OS X</th>
<th class="col" align="center" style="padding-left:2em;padding-right:2em;">Windows</th>
</tr>
<tr><td style="font-weight:bold;">CMUCL</td>    <td align="center">PP</td><td > </td><td></td></tr>
<tr><td style="font-weight:bold;">OpenMCL</td>  <td align="center"></td><td align="center">NT, PP</td><td></td></tr>
<tr><td style="font-weight:bold;">SBCL</td>     <td align="center">NT, PP</td><td align="center"></td><td></td></tr>
</table>


</div>

<h5>Notes:</h5>

<ol>
<li>Both threaded and periodic versions of <code>rts</code> are
supported in OpenMCL and SBCL.  The default implementation is
threaded. To try out the periodic version set <code>*rts-type*</code>
to <code class="keyword">:periodic</code>.
</lu>

<li>Periodic polling has several consequences:
</p>  
<ul>
<li>Using the GUI at the same time as periodic rts or periodic
receiving will currently not work.</li>
<li>Periodic tasks are pushed onto a task list; if <code>rts</code> is
periodic be sure to start it running before
calling <a href="set-receiver-fn.html">set-receiver!</a>
otherwise <code>rts</code> will not be able to process what the
receiver places into its queue until the next tick.</li>
<li>All receiving and process tasks must happen within the 1
millisecond tick or things will drift.
</li>
</ul>
</li>

<li>
How close <code>rts</code> actually gets to accurate real time
rendering depends on a number of factors, including how accurate the
Lisp implementation's thread sleeping/periodic tasks are, how
short the time deltas between musical events are, whether process code
is compiled or interpreted, how much garbage is generated, and so on.
</li>
</ol>


<h4>Examples:</h4>
<div class="float">
<p class="captxt">
<span class="floatlabel">Example 1. </span> Starting <code>rts</code> and sprouting from the REPL.
</p>
<pre class="code">
(<span class="special">defparameter</span> <span class="defined">*pm*</span>
  (<a href="portmidi-topic.html#portmidi-open">portmidi-open</a> <span class="keyword">:output</span> 3 <span class="keyword">:latency</span> 0))

(<span class="special">define</span> (<span class="defined">zzz</span> len lb ub wai amp)
  (<a href="process-mac.html">process</a> repeat len
           output (<a href="new-mac.html">new</a> <a href="midi-cls.html">midi</a> <span class="keyword">:time</span> (<a href="now-fn.html">now</a>)
                       <span class="keyword">:duration</span> .1 <span class="keyword">:amplitude</span> amp
                       <span class="keyword">:keynum</span> (<a href="between-fn.html">between</a> lb ub))
           wait wai))

<span class="comment">;;; fire it up for 25 seconds</span>

(rts (list (zzz 100 60 90 .25 .5)
           (zzz 50 20 50 .5 .5))
     *pm*)

<span class="comment">;;; add stuff while zzz plays</span>

(<span class="special">let</span> ((k (<a href="between-fn.html">between</a> 20 100))
      (n (<a href="pick-fn.html">pick</a> 3 5 7 11)))
  (<a href="sprout-fn.html">sprout</a> (zzz (* n (<a href="pick-fn.html">pick</a> 2 3 4))
               k
               (+ k 7)
               (/ 1 n)
               .75)))
</pre>
</div>

<div class="float">
<p class="captxt">
<span class="floatlabel">Example 2. </span>Endless Fluff. Stops only when <a href="rts-stop-fn.html">rts-stop</a> is called. (Todd Ingalls)
</p>
<pre class="code">
(<span class="special">define</span> <span class="defined">fluff</span> '(60 62 64 67 72 65 69 48 50))

(<span class="special">define</span> (<span class="defined">endless-fluff</span> num dur knums)
  (<a href="process-mac.html">process</a> repeat num for i from 0 
	   output
           (<a href="new-mac.html">new</a> <a href="midi-cls.html">midi</a> <span class="keyword">:time</span> (<a href="now-fn.html">now</a>) 
                <span class="keyword">:duration</span> (* 2 dur)
                <span class="keyword">:amplitude</span> .5
                <span class="keyword">:keynum</span> (<a href="pickl-fn.html">pickl</a> fluff))
	   wait (<a href="pick-fn.html">pick</a> dur (/ dur 2) (/ dur 4))
	   when (= i (1- num))
	   sprout (<a href="process-mac.html">process</a> repeat 4
                           output (<a href="new-mac.html">new</a> <a href="midi-cls.html">midi</a> <span class="keyword">:time</span> (<a href="now-fn.html">now</a>) 
                                       <span class="keyword">:duration</span> 5
                                       <span class="keyword">:amplitude</span> .5 
                                       <span class="keyword">:keynum</span> (<a href="pickl-fn.html">pickl</a> knums)))
	   and
	   sprout (endless-fluff 20 1 knums)))

(rts (endless-fluff 20 1 fluff) *pm* 0 #f)

<span class="comment">;;; stop when you are done.</span>

(<a href="rts-stop-fn.html">rts-stop</a>)
</pre>
</div>

<div class="float">
<p class="captxt">
<span class="floatlabel">Example 3. </span>Sprouting into the scheduler from a receive hook.
</p>
<pre class="code">
(<span class="special">define</span> <span class="defined">*pm*</span> (<a href="portmidi-topic.html#portmidi-open">portmidi-open</a> <span class="keyword">:input</span> 1 <span class="keyword">:output</span> 3 <span class="keyword">:latency</span> 0))

(<span class="special">define</span> (<span class="defined">major-thirds</span> len knum)
  (<a href="process-mac.html">process</a> with d = .1
           for i below len
           for k = (+ knum (* (mod i 5) 4))
           output (<a href="midi-topic.html#make-note-on">make-note-on</a> 0 k 90) at (<a href="now-fn.html">now</a>)
           sprout (<a href="midi-topic.html#make-note-off">make-note-off</a> 0 k 125) at (+ (<a href="now-fn.html">now</a>) .5)
           wait d))

(rts #f *pm*)

(<a href="set-receiver-fn.html">set-receiver!</a> (<span class="special">lambda</span> (mm ms) ms
                 (<span class="special">if</span> (<a href="midi-topic.html#note-on-p">note-on-p</a> mm)
                   (<a href="sprout-fn.html">sprout</a> (major-thirds 20 (<a href="midi-topic.html#note-on-key">note-on-key</a> mm)))))
               *pm*)

<span class="comment">;;; stop receiving and scheduling.</span>

(<a href="remove-receiver-fn.html">remove-receiver!</a> *pm*)

(<a href="rtsqmk-fn.html">rts?</a>)
<span class="result">&rArr;</span> #t

(<a href="rts-stop-fn.html">rts-stop</a>)

(<a href="rtsqmk-fn.html">rts?</a>)
<span class="result">&rArr;</span> #f
</pre>
</div>






<h4>See also:</h4>
<ul>
<li><a href="rtsqmk-fn.html"><code>rts?</code></a> [Function]</li>
<li><a href="rts-stop-fn.html"><code>rts-stop</code></a> [Function]</li>
<li><a href="set-receiver-fn.html"><code>set-receiver!</code></a> [Function]</li>
<li><a href="sprout-fn.html"><code>sprout</code></a> [Function]</li>

</ul>

</div> <!-- end content -->
<hr class="inv"/>
<!-- Rtster -->
<div id="rtster">
<div id="version">$Name$</div>
<div id="cvs-info">($Revision$, $Date$)</div>
</div>
</body>
</html>
