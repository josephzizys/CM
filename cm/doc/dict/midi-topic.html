<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1"/>
<style type="text/css" media="all">
@import "../css/cm.css";
</style>
<title>Midi</title>
</head>
<body>
<div id="content">

<!-- Entry: "midi-text-evemt" -->
<dl class="dictsyntax">
<dt>[Topic]</dt>
<dd><span class="syntax">MIDI</span></dd>
</dl>

<p>
Common Music supports reading and writing all types of MIDI messages
to MIDI files and to the <a
href="http:www.grame.fr/MidiShare">Midishare</a> real time operating
system. Two levels of MIDI support are provided:
</p>

<ul>

<li>
A <a href="#midi_real_time">low level interface</a> connects directly
to Midishare via a foreign function interface (FFI) for "interactive",
real time work (OpenMCL/OS X systems only).
</li>

<li>
A <a href="#midi_high_level">high level interface</a> provides Lisp
classes and methods for generating music to MIDI score files and to
MidiShare in non-real time mode.
</li>

</ul>

<h2 id="midi_real_time">Low level (real time) MIDI support</h2>

<p>
The low level MIDI interface provides the ability to read and write
MIDI messages in real time on:
</p>

<ul>
<li><a
href="http://www.grame.fr/MidiShare/Install/Download.html#MacOSX"> OS
X MidiShare</a> using <a
href="http://www.clozure.com/openmcl/">OpenMCL</a> (release 0.14.1-p1
or higher.)</li>
</ul>



<h3>Opening and closing the MIDI port</h3>

<p>
In order to work with Midishare in real time, a connection between CM
and MidiShare must first be established. This connection is
represented by an object called the <em>midi port</em>:
</p>

<dl>
<dt>(<code class="entry">midi-open</code>)</dt>
<dd>Opens connection to MidiShare.</dd>
<dt>(<code class="entry">midi-close</code>)</dt>
<dd>Closes connection to MidiShare.</dd>
<dt>(<code class="entry">midi-open?</code>)</dt>
<dd>Returns the midi port object if MidiShare is open, otherwise false.</dd>
<!-- dt>(<code class="entry">midi-reset </code>[<code class="keyword">:port </code><em>integer</em>]<code class="entry"></code>)</dt>
<dd>Sends system reset to a MidiShare output port, which defaults to 0.</dd -->
<dt><code class="entry">*mp*</code></dt>
<dd>
CM's <em>reference number</em> in MidiShare when the MIDI port is
open, otherwise false.
</dd>
</dl>

<!-- Interaction 1 -->
<div class="float">
<p><span class="floatlabel">Example 1.</span> Opening the MIDI port.</p>
<pre class="shell">cm&gt; <span class="input">(midi-open?)</span>
<span class="output">nil</span>
cm&gt; <span class="input">(midi-open)</span>
<span class="output">#&lt;midi-port "midi.port"&gt;</span>
cm&gt; <span class="input">(midi-open?)</span>
<span class="output">#&lt;midi-port "midi.port"&gt;</span>
cm&gt; <span class="input">*mp*</span>
<span class="output">1</span>
</div>


<h3>Midishare's MidiEv struct</h3>

<p>
Once a connection between CM and MidiShare has been established, MIDI
messages can be sent to and from MidiShare ports and client
applications in real time. MidiShare implements MIDI messages using a
C struct called a MidiEv.  MidiEvs are <em>foreign</em> objects in
Lisp:
</p>

<ul>
<li>they are allocated and deallocated outside of Lisp's
memory partition</li>
<li>they are not part of the Lisp datatype system</li>
<li>they are not managed by Lisp's garbage collection facility</li>
<li>they are not trapped and handled by Lisp's error system</li>
</ul>

<p>
You are completely responsible for properly managing the MidiEv's you
allocate and use. In some cases this may include
explicit <em>deallocation</em> after a MidiEv has been sent or received.
Be sure to consult the 
<a href="http://www.grame.fr/MidiShare/Doc/MidiShare_doc.html">
Midishare manual</a> and the <a
href="../../src/midishare/Midishare-Interface.lisp">Midishare Lisp
interface</a> for information about how to create, read, write and
deallocate MidiEv structs using Midishare's API.
</p>

<p>
Common Music "extends" Midishare's API by defining
<code>ms:new</code>, a high level MidiEv constructor, and
<code>ms:MidiPrintEv</code>, a MidiEv printer. These two additions
allow MidiEvs to be manipulated in a manner consistent with normal
Lisp objects defined in CM. Note that you must use the package prefix
<code>midishare:</code> or <code>ms:</code> to reference these two
functions -- as well as all of the functions defined by MidiShare --
from inside the CM package.
</p>

<dl>
<dt>
<span class="syntax" id="ms:new">(<code class="entry">ms:new</code> <var>type</var> {<var style="color:#b22222;">:keyword</var> <var>value</var>}*)</span>
</dt>
<dd>
Allocates, initializes and returns a foreign Midishare
event. <var>Type</var> is an integer MidiEv type specifier (see below)
followed by zero or more keyword parameters as appropriate for the
type of MidiEv returned.
</p>

<p>Keyword arguments applicable to all MidiEvs:</p>
<dl>
<dt><code class="keyword">:port</code> <var>integer</var></dt> <dd>The
reference number of the MidiShare port to send the event to. Defaults
to 0.</dd> <dt><code class="keyword">:channel</code>
<var>integer</var></dt> <dd>The channel number to send the event
to. Defaults to 0.</dd> <dt><code class="keyword">:date</code>
<var>integer</var></dt> <dd>The time (in milliseconds) of the
event. Defaults to 0.</dd>
</dl>

<p>
Every type of MidiEv is identified by a unique integer <em>type
id</em>, a Lisp constant (symbol) with an integer value.  The
following list provides the name, value and <code
class="entry">ms:new</code> keyword arguments for each type of MidiEv:
</p>

<dl>
<!-- begin types -->
<dt><code>typeNote</code> (0)</dt>
<dd>
A MidiShare key event with an associated millisecond duration.
<dl>
<dt><code class="keyword">:keynum</code> <em>integer</em></dt>
<dd>An integer key number 0-127. Defaults to 60.</dd>
<dt><code class="keyword">:velocity</code> <em>integer</em></dt>
<dd>An integer velocity 0-127. Defaults to 60.</dd>
<dt><code class="keyword">:duration</code> <em>integer</em></dt>
<dd>Duration in milliseconds, defaults to 500.
</dl>
</dd>

<dt><code>typeKeyOn</code> (1), <br/>
    <code>typeKeyOff</code> (2)</dt>
<dd>
Like <code>typeNote</code> but with no millisecond <code
class="keyword">:duration</code>.
</dd>

<dt><code>typeKeyPress</code> (3)</dt>
<dd>
<dl>
<dt><code class="keyword">:keynum</code> <em>integer</em></dt>
<dd>An integer key number 0-127. Defaults to 60.</dd>
<dt><code class="keyword">:pressure</code> <em>integer</em></dt>
<dd>An integer pressure 0-127. Defaults to 0.</dd>
</dl>
</dd>

<dt><code>typeCtrlChange</code> (4)</dt>
<dd>
<dl>
<dt><code class="keyword">:controller</code> <em>integer</em></dt>
<dd>An integer controller 0-127. Defaults to 0.</dd>
<dt><code class="keyword">:change</code> <em>integer</em></dt>
<dd>An integer change 0-127. Defaults to 0.</dd>
</dl>
</dd>

<dt><code>typeProgChange</code> (5)</dt>
<dd>
<dl>
<dt><code class="keyword">:program</code> <em>integer</em></dt>
<dd>An integer program 0-127. Defaults to 0.</dd>
</dl>
</dd>

<dt><code>typeChanPress</code> (6)</dt>
<dd>
<dl>
<dt><code class="keyword">:pressure</code> <em>integer</em></dt>
<dd>An integer pressure 0-127. Defaults to 0.</dd>
</dl>
</dd>

<dt><code>typePitchBend</code> (7),<br/>
     <code>typePitchWheel</code> (7)</dt>
<dd>
<dl>
<dt><code class="keyword">:bend</code> <em>integer</em></dt>
<dd>An integer bend value -8192 to 8191. Defaults to 0 (no bend).</dd>
</dl>
</dd>

<dt><code>typeSongPos</code> (8)</dt>
<dd>
<dl>
<dt><code class="keyword">:lsb</code> <em>integer</em></dt>
<dd>An integer 0-127. Defaults to 0.</dd>
<dt><code class="keyword">:msb</code> <em>integer</em></dt>
<dd>An integer 0-127. Defaults to 0.</dd>
</dl>
</dd>

<dt><code>typeSongSel</code> (9)</dt>
<dd>
<dl>
<dt><code class="keyword">:song</code> <em>integer</em></dt>
<dd>An integer song 0-127. Defaults to 0.</dd>
</dl>
</dd>


<dt>
<code>typeClock</code> (10),<br/>
<code>typeStart</code> (11),<br/>
<code>typeContinue</code> (12),<br/>
<code>typeStop</code> (13),<br/>
<code>typeTune</code> (14),<br/>
<code>typeActiveSens</code> (15),<br/>
<code>typeReset</code> (16)
<dd>
No keyword parameters.
</dd>

<dt><code>typeSysEx</code> (17)</dt>
<dd>
<dl>
<dt><code class="keyword">:data</code> <em>list</em></dt> <dd>A list
of data bytes. Do not include a leading #xF0 or tailing #xF7 in the
list; these markers are added automatically by Midishare.</dd>
</dl>
</dd>
</dl>


<p>
The following MIDI Meta messages <em>cannot</em> be sent to an
external synthesizer:
</p>

<dl>
<dt><code>typeSeqNum</code> (134)</dt>
<dd>
<dl>
<dt><code class="keyword">:number</code> <em>integer</em></dt>
<dd>A sequence integer 0-127.</dd>
</dl>
</dd>

<dt>
<code>typeTextual</code> (135),<br/>
<code>typeCopyright</code> (136),<br/>
<code>typeSeqName</code> (137),<br/>
<code>typeInstrName</code> (138),<br/>
<code>typeLyric</code> (139),<br/>
<code>typeMarker</code> (140),<br/>
<code>typeCuePoint</code> (141)<br/>
<dd>
<dl>
<dt><code class="keyword">:text</code> <em>string</em></dt>
<dd>A text string, defaults to "".</dd>
</dl>
</dd>

<dt>
<code>typeChannelPrefix</code> (142)
</dt>
<dd>
<dl>
<dt><code class="keyword">:prefix</code> <em>integer</em></dt>
<dd>A prefix integer 0-127, defaults to 0.</dd>
</dl>
</dd>

<dt>
<code>typeEndTrack</code> (143)
</dt>
<dd>No keyword parameters.</dd>

<dt>
<code>typeTempo</code> (144)
</dt>
<dd>
<dl>
<dt><code class="keyword">:tempo</code> <em>integer</em></dt>
<dd>Tempo in quarter notes per minute, defaults to 120.</dd>
</dl>
</dd>

<dt>
<code>typeSMPTEOffset</code> (145)
</dt>
<dd>
<dl>
<dt><code class="keyword">:offset</code> <em>list</em></dt> <dd>A list
of SMPTE integer offsets (<em>hr min sec frame subframe</em>).</dd>
</dl>
</dd>

<dt>
<code>typeTimeSign</code> (146)
</dt>
<dd>
<dl>
<dt><code class="keyword">:numerator</code> <em>integer</em></dt>
<dd>The upper number of the time signature, defaults to 4.</dd>
<dt><code class="keyword">:denominator</code> <em>integer</em></dt>
<dd>The lower number of the time signature, defaults to 4.</dd>
<dt><code class="keyword">:clocks</code> <em>integer</em></dt>
<dd>Clocks per quarter, defaults to 24.</dd>
<dt><code class="keyword">:32nds</code> <em>integer</em></dt>
<dd>Thirty-seconds per quarter, defaults to 8.</dd>
</dl>
</dd>

<dt>
<code>typeKeySign</code> (147)
</dt>
<dd>
<dl>
<dt><code class="keyword">:sign</code> <em>integer</em></dt> 
<dd>The number of flats or sharps in the key signature -7 to 7,
defaults to 0.</dd> 

<dt><code class="keyword">:mode</code><em>integer</em></dt> 
<dd>An integer 0 or 1 where 0 means major and 1
means minor, defaults to 0.</dd>
</dl>
</dd>
<!-- end types -->
</dl>
</dd>
<!-- end ms:new -->
<dt>
<br/>
<span class="syntax">
(<code class="entry">ms:MidiPrintEv</code> <var>ev</var> [<var>stream</var>])
</span>
</dt>
<dd>Formats the message contents of <var>ev</var> to <var>stream</var>, which defaults to the standard output.
</dd>

</dl>

<!-- Interaction 1 -->
<div class="float">
<p><span class="floatlabel">Example 2.</span> Creating and printing a MidiEv.</p>
<pre class="shell">cm&gt; <span class="input">(define ev (ms:new typeNote :channel 3 :duration 2000))</span>

cm&gt; <span class="input">(ms:MidiPrintEv ev)</span>
<span class="output">#&lt;MidiEv Note [0/3 0ms] 60 64 2000ms&gt;</span></pre>
</div>

<p>
To access and set the fields of a MidiEv struct you should use the
functions defined in the MidiShare API. The more important
constructors and accessors are listed here. Consult the <a
href="http://www.grame.fr/MidiShare/Doc/MidiShare_doc.html">MidiShare
documentation</a> for more information.
</p>

<ul>
<li>(<code>ms:MidiNewEv </code><var>typenum</var>)</code></li>
<li>(<code>ms:MidiCopyEv </code><var>ev</var>)</li>
<li>(<code>ms:MidiFreeEv </code><var>ev</var>)</li>
<li>(<code>ms:evtype </code><var>ev</var> [<var>val</var>])
<li>(<code>ms:port </code><var>ev</var> [<var>val</var>])
<li>(<code>ms:chan </code><var>ev</var> [<var>val</var>])
<li>(<code>ms:date </code><var>ev</var> [<var>val</var>])
<li>(<code>ms:pitch </code><var>ev</var> [<var>val</var>])
<li>(<code>ms:dur </code><var>ev</var> [<var>val</var>])
<li>(<code>ms:vel </code><var>ev</var> [<var>val</var>])
<li>(<code>ms:bend </code><var>ev</var> [<var>val</var>])
<li>(<code>ms:pgm  </code><var>ev</var> [<var>val</var>])
<li>(<code>ms:ctl </code><var>ev</var> [<var>val</var>])</li>
<li>(<code>ms:val </code><var>ev</var> [<var>val</var>])</li>
<li>(<code>ms:field </code><var>ev pos</var> [<var>val</var>])</li>
</ul>

<!-- Interaction 3 -->
<div class="float">
<p><span class="floatlabel">Example 3.</span> Copying and transposing an event by one octave.</p>
<pre class="shell">cm&gt; <span class="input">(define ev2 (ms:MidiCopyEv ev))</span>

cm&gt; <span class="input">(ms:pitch ev2 (+ (ms:pitch ev2) 12))</span>
<span class="output">72</span>
cm&gt; <span class="input">(ms:MidiPrintEv ev2)</span>
<span class="output">#&lt;MidiEv Note [0/3 0ms] 72 64 2000ms&gt;</span></pre>

</div>



<h3>Real time MIDI output</h3>
<p>
Real time MIDI output and musical process scheduling is initiated by
calling <a href="output-fn.html"><code>output</code></a>,
<a href="sprout-fn.html"><code>sprout</code></a> and 
<a href="now-fn.html"><code>now</code></a> <em>outside</em> the dynamic
scope of a call to <a href="events-fn.html"><code>events</code></a>.
When used interactively these functions behave as if they were defined
slightly differently than during non-real time event scheduling:

<dl>
<dt><span class="syntax">(<code class="entry">now</code>)</span></dt>
<dd>Returns Midishare's current clock time in milliseconds.</dd>

<dt>
<span class="syntax">(<code class="entry">output</code> <var>ev</var> [<var>ahead</var>])</span>
</dt>
<dd>
Sends <var>ev</var> to Midishare immediately or <var>ahead</var>
milliseconds later than when the function is called. No value is
returned.
</dd>

<dt>
<span class="syntax">(<code class="entry">sprout</code> <var>fn</var> [<var>ahead</var>])</span>
</dt>
<dd>
Schedules the process function <var>fn</var> to run as a real time
Midishare task immediately or <var>ahead</var> milliseconds later than
when the function is called. No value is returned.
</dd>
</dl>

<!-- Interaction 4 -->
<div class="float">
<p><span class="floatlabel">Example 4.</span> Outputting and sprouting.</p>
<pre class="shell">cm&gt; <span class="input">(now)</span>
<span class="output">274601</span>
cm&gt; <span class="input">(output (ms:new typeNote :keynum 80 :duration 1000))</span>

cm&gt; <span class="input">(define (rankeys reps rhy dur lb ub)
      (process repeat reps
               output (ms:new typeNote :duration dur
                              :keynum (between lb ub))
               wait rhy))</span>

cm&gt; <span class="input">(sprout (rankeys 30 200 250 60 90) 2000)</span></pre>
</div>

<h3>Real time MIDI input</h3>
<p>
Use the <code>receive</code> function to establish or remove a MIDI
input hook. 

<dl>
<dt><span class="syntax">(<code class="entry">receive</code>  [<var>hook</var>])</span>
<dd> If called with no argument <code>receive</code> removes the
current MIDI input hook. Otherwise, <var>hook</var> is a function of
one argument that will be funcalled with every MIDI input event as
soon as MidiShare receives it. The <code>receive</code> function does
not return a value.
</dd>
</dl>

<!-- Interaction 5 -->
<div class="float">
<p><span class="floatlabel">Example 5.</span> Establishing and
clearing a MIDI receive hook.</p>
<pre class="shell">cm&gt; <span class="input">(define (play9th ev)
      (output ev)
      (let ((ev2 (ms:MidiCopyEv ev)))
         (ms:pitch ev2 (+ 13 (ms:pitch ev2)))
         (output ev2)))</span>

cm&gt; <span class="input">(receive #'play9th)</span>

cm&gt; <span class="input">(receive )</span></pre>
</div>

<h3>Example: receiving and scheduling in tandem</h3> 

<p>
The following example demonstrates real time processes and a receive
hook used together. The <code>wiggle</code> process adds a "chromatic
wiggle" to a specified keynum <var>knum</var>.  Each wiggle lasts
between 10 and 20 notes; each note is produced from a heap pattern
(random shuffle) of keynums centered around <var>knum</var> not
exceeding a minor third on either side. The rate (speed) of each
wiggle is a random choice between 100, 150 and 200 milliseconds between
notes.  All wiggles make a decrescendo over their lifetime.
</p>

<p>
The receive hook <code>dowiggle</code> first outputs the current input
note and then 75% of the time it adds a wiggle to it.  Half of these
wiggles are at the input key number, otherwise they appear one octave
up or down from the input note.
</p>

<!-- Interaction 6 -->
<div class="float">
<p><span class="floatlabel">Example 6.</span> Receiving, outputting and scheduling used together.</p>
<pre class="code">
(<span class="special">define</span> (<span class="defined">wiggle</span> knum)
  <span class="comment">;; return a wiggle process centered on specified knum</span>
  (<span class="special">let</span> ((n (between 10 20))
        (r (pick 100 150 200))
        (h (new heap <span class="keyword">:of</span> '(0 -1 1 -2 2 -3 3))))
    (<span class="special">process</span> for i below n
             output (<span class="special">ms:new</span> typeNote
                       <span class="keyword">:duration</span> 250
                       <span class="keyword">:keynum</span> (+ knum (next h))
                       <span class="keyword">:velocity</span> (round (interp i 0 90 (- n 1) 20)))
             wait r)))

(<span class="special">define</span> (<span class="defined">dowiggle</span> ev)
  <span class="comment">;; a receive hook to sprout wiggles</span>
  (output ev)
  (<span class="special">if</span> (and (= (ms:evType ev) typeKeyOn)
           (> (ms:vel ev) 0)
           (odds .75))
      (sprout (wiggle (+ (ms:pitch ev)
                         (pick 0 0 12 -12)))
              0)))</span>
</div>

<!-- Interaction 6 -->
<div class="float">
<p><span class="floatlabel">Example 7.</span> Interactive wiggling.</p>
<pre class="shell">
cm&gt; <span class="input">(midi-open)</span>
<span class="output">#&lt;midi-port "midi.port"&gt;</span>

<span class="comment">;;; listen to a few wiggles on their own</span>

cm&gt; <span class="input">(sprout (wiggle 60))</span>

cm&gt; <span class="input">(sprout (wiggle 40) 1000)</span>

<span class="comment">;;; wiggle till the cows come home!</span>

cm&gt; <span class="input">(receive #'dowiggle)</span>

cm&gt; <span class="input">(receive )</span></pre>
</div>

<h2 id="real_time_tip">Real time processing issues</h2>

<ul>
<li>
  Garbage collection (GC) is not disabled.  You may or may not want
  to do this on your own.
</li>

<li>
  Regardless of GC status you should should keep consing to a minimum
  during real time work. The most common Lisp activities that cons
  are:
  <ul>
  <li>Creating Lisp instances, structures, vectors, arrays, strings and
  lists.</li>
  <li>Performing floating point and fractional arithmetic.</li>
  </ul>
</li>
<li>
  A rule of thumb: integers are good, everything else is
  suspect. Analyze your programs to determine when and where you use
  floats to see if there is an integer alternative.
</li>

<li>
  Do your consing ahead of time. For example allocate all your
   patterns before you call <code>sprout</code>.
</li>

<li>
  Real time processes are managed in a "processes table".  
  By default the size of this table is 64.  When a process function is
  finished it is automatically removed from the table and that
  location will be reallocated for the next process.  If 64 concurrent
  process are not enough you can use <code>make-proctable</code> to
  increase the size of the table:
  <blockquote>
    <pre>(set! *proctable* (make-proctable 200))</pre>
  </blockquote>
</li>

<li>
  If you trigger an error during real time process scheduling you
  should reset the proctable back to its initial conditions before
  calling <code>sprout</code> again:
  <blockquote>
    <pre>(reset-proctable *proctable*))</pre>
  </blockquote>
</li>
</ul>

<h2 id="midi_high_level">High level (non-real time) MIDI support</h2>

<p>
High level MIDI support consists of class definitions of MIDI scores
and events and functions that operate on them in non-real time.  Note
that <em>non-real</em> does not imply <em>slower</em> than real
time -- in most cases the high level interface generates output many
times faster than real time.  High level support is documented by main
entries in the Common Music dictionary, the following topic list
provides links to this documentation:
</p>

<h3>MIDI score classes</h3>

<ul>
<li><a href="midi-file-stream-cls.html"><code>midi-file-stream</code></a></li>
<li><a
href="midishare-stream-cls.html"><code>midishare-stream</code></a></li>
<li><a href="player-stream-cls.html"><code>player-stream</code></a></li>
</ul>

<h3>MIDI event classes</h3>

<ul>
<li><a href="midi-cls.html"><code>midi</code></a></li>
<li><a href="midi-note-on-cls.html"><code>midi-note-on</code></a></li>
<li><a href="midi-note-off-cls.html"><code>midi-note-off</code></a></li>
<li><a href="midi-key-pressure-cls.html"><code>midi-key-pressure</code></a></li>
<li><a href="midi-control-change-cls.html"><code>midi-control-change</code></a></li>
<li><a href="midi-program-change-cls.html"><code>midi-program-change</code></a></li>
<li><a href="midi-channel-pressure-cls.html"><code>midi-channel-pressure</code></a></li>
<li><a href="midi-pitch-bend-cls.html"><code>midi-pitch-bend</code></a></li>
<li><a href="midi-system-event-cls.html"><code>midi-system-event</code></a></li>
</ul>

<h3>MIDI functions</h3>

<ul>
<li><a href="events-fn.html"><code>events</code></a></li>
<li><a href="import-events-fn.html"><code>import-events</code></a></li>
<li><a href="midi-file-print.html"><code>midi-file-print</code></a></li>
<li><a href="osx-play-midi-file.html"><code>osx-play-midi-file</code></a></li>
<li><a href="win-play-midi-file.html"><code>win-play-midi-file</code></a></li>
<li><a href="set-midi-output-hook-fn.html"><code>set-midi-output-hook!</code></a></li>
</ul>





<!-- Footer -->
<div id="footer">
<div id="version">$Name$</div>
<div id="cvs-info">($Revision$, $Date$)</div>
</div>
</body>
</html>
