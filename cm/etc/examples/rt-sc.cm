;;; **********************************************************************
;;; $Name$
;;; $Revision$
;;; $Date$
;;;
;;; Supercollider examples, by Todd Ingalls. Load the file and then

(in-package :cm)

(defobject simple (scsynth)
  ((freq :initform 440)
   (dur :initform 1)
   (amp :initform .2)
   (pan :initform 0))
  (:parameters freq dur amp pan time))

(defobject reverb1 (scsynth)
  ((mix :initform .2)
   (decaytime :initform 15)
   (in :initform 0)
   (out :initform 0))
  (:parameters mix decaytime in out time))

(defobject reverb2 (scsynth)
  ((mix :initform .2)
   (decaytime :initform 15))
  (:parameters mix decaytime time))

(defobject play-buffer (scsynth)
  ((bufnum)
   (amp :initform 1.0)
   (rate :initform 1.0)
   (looping :initform 1)
   (out :initform 0))
  (:parameters bufnum amp rate looping out time))

(defobject granulate (scsynth)
  ((dur :initform 1)
   (amp :initform 1.0)
   (bufnum)
   (rate :initform 1.0)
   (gdur :initform .1)
   (speed :initform 1.0)
   (out :initform 0))
  (:parameters dur amp bufnum rate gdur speed out time))

(defobject simple-osc (scsynth)
  ((freq :initform 440)
   (dur :initform 1)
   (bufnum)
   (amp :initform .2)
   (pan :initform 0))
  (:parameters freq dur amp pan bufnum time))


(defobject fm-env (scsynth)
  ((freq :initform 440)
   (mratio :initform 1.0)
   (index :initform 1.0)
   (amp :initform 1.0)
   (dur :initform 1)
   (ampenv :initform #f)
   (indexenv :initform #f))
  (:parameters freq mratio index amp dur time ampenv indexenv))


(defobject randomness1 (scsynth)
  ((density :initform 1)
   (id :initform 1))
  (:parameters density id time))


;;;
;;;
;;;


(define (sc-simple-1 num)
  (process repeat num 
	   output (new simple :time (now) 
		       :freq (between 300 700)
		       :dur (between 10 20)
		       :amp .1
		       :pan (pickl '(-1.0 0 1.0)))
	   wait (between 2.0 3.0)))

;;; (define *sc* (sc-open))
;;; 
;;; (sc-dumposc t)
;;;
;;; (rts nil *sc*)
;;;
;;; (sprout (sc-simple-1 10))

(define (sc-fm-2 num)
  (process repeat num for i from 0
	   with envs = (new heap :of '((0 0.0 50 1.0 100 0.0)
				       (0 0 1 1.0 20 .3 70 .2 100 0.0)
				       (0 0 20 1.0 40 .2 60 1.0 100 0.0)
				       (0 0 5 1.0 20 0.0 100 0.0)))
	   when (= i 0)
	   output (new reverb2 :time (now) 
		       :node 500
		       :decaytime 0.8
		       :mix .05)
	   output (new fm-env :freq (between 300 700) 
		       :mratio (between .4 3.2) 
		       :dur 4
		       :index 1.0
		       :amp .7
		       :node (+ i 1000)
                       :ampenv (new sc-env :envelope (next envs)
                                    :duration 4)
                       :indexenv (new sc-env :envelope (next envs)
                                      :duration 4)
		       :time (now)
		       :add-action 0)
	   wait 3))
;;;
;;; (sprout (sc-fm-2 10))
;;;

;;; 
;;;
;;; 
;;; 
;;; (rts nil *sc*)

;;; (sprout (simple-tendency1 100 .05 '(0 0 .10 200 .4  800 .6 900 1.00 1000.0) '(0 0 .20 300 .4  900 1.00 2000.0)))
;;; (sprout (simple-tendency1 100 .01 '(0 400 .10 200 .4  400 .6 100 1.00 400.0) '(0 400 .10 1600 .4  400 .6 1700 1.00 400.0)))

;;; (rts-stop) 


(defun sim (num)
  (process repeat num for i from 0
	   when (= i 0)
	   output (new sc-buffer :bufnum 11
		       :time 0
		       :frames 512
		       :flags :normalize
		       :with-gen '(:sine1 '(1 .1 .1 .1 .9 .01 .3 .1 1 1)))

	   output (new buffer-get :time (now) :bufnum 11 :samples (mod i 512))
	   wait .05))

;;; (rts nil *sc*)
;;; (sprout (sim 10))
;;; (rts-stop)
;;; (rts-reset)




;;;
;;; (set-receive-mode! *sc* :object)

(define (sim-reply m)
  (let ((freq-scale 1.0))
    (if (is-a? m 'buffer-get-reply)
	(begin 
	 (set! freq-scale (second (slot-value m 'samples-values)))
	 (output (new simple :time (now) :amp .1 :dur .5 :freq (+ 400 (abs (* 440 freq-scale))))
	       :to *sc*)))))

;;; (set-receiver! #'sim-reply *sc*)
;;; (remove-receiver! *sc*)

;;;; (sc-notify t)



(define (start-randomness1a)
  (process repeat 1
	   output (new randomness1 :time (now) :density 2 :id 100 :node 2000)))


;;; (rts nil *sc*)
;;; (sprout (start-randomness1a))
;; (set-receiver! #'trig-rep *sc*)


(define (trig-rep m)
  (if (is-a? m 'trigger-reply)
      (if (= (trigger-id m) 100)
	  (output (new simple :amp .1 :dur 1 :freq (+ 100 (abs (slot-value m 'value)))
		       :time (now)))))
  
;;; (rts-stop)

;;; (remove-receiver! *sc*)


#|

(sc-notify t)
(sc-status)


(set-receiver! #'(lambda (x)
		   (if (is-a? x 'status-reply)
		       (print (round (slot-value x 'sample-rate)))))
	       ;(status-sample-rate x)))
	       *sc*)

		   (if (is-a? x 'status-reply)
		       (print x)))
	       *sc*)

(remove-receiver! *sc*)

(setf (slot-value *sc* 'recmode) :object)

(/ 44100.0 256)

|#