This is the readme for Common Music 3. 

  1. Applications
  2. Dependancies
  3. Building
  4. CM in Emacs
  5. SVN Access
  6. Developing
  7. Porting

==========================================================================
                               APPLICATIONS
==========================================================================

The source tree builds three target applications:

Grace   (Graphical Realtime Algorithmic Composition Environment) 

   A drag-and-drop GUI with embedded scheme interpreter (Sndlib or
   Chicken Scheme), code editor, data plotting, and realtime audio
   connections to various services like as MIDI, CLM, Csound, Fomus.

cm 

   A console (non-gui) version of Grace that can run as an 'inferior
   process' under Emacs (see section 4 below) or in a Terminal window.

GraceCL
    
   A non-realtime version of Grace to use with Common Music 2 and
   either SBCL or CLISP Common Lisp.

==========================================================================
                               DEPENDENCIES                               
==========================================================================

Premake (3.5, 3.6, 3.7) available at:

    http://premake.sourceforge.net/download

Either SndLib with S7 Scheme, available at:

    ftp://ccrma-ftp.stanford.edu/pub/Lisp/sndlib.tar.gz

OR Chicken Scheme 3.0.0, available at:

    http://www.call-with-current-continuation.org/

==========================================================================
                                 BUILDING                                 
==========================================================================

Use premake to create your make files and then make the targets. For
example this is how I build the basic system on my mac:

    $ premake --target gnu --sndlib ../sndlib
    $ make

You MUST specify a --target option (either gnu or vs2005) and EITHER a
--sndlib OR a --chicken installation (directory) that contains the system's header files and static lib for linking.

To use an external JUCE installation rather than the amalgamated
sources (part of the CM source tree) pass an optinal --juce
installation directory.  To build with Fomus add your --fomus
installation directory as well.

The --sndlib --chicken, --juce and --fomus options all allow their
path to be either the source directory (eg '--juce ../juce-1.46') or
an install root (eg '--juce /usr/local').

Executables are saved in bin/:

    bin/cm                      console app    
    bin/Grace                   gui app
    bin/GraceCL                 gui app (for cm2/common lisp)

BUILDING SNDLIB:

    $ cd /path/to/sndlib
    $ ./configure CC=g++
    $ make

==========================================================================
                                 CM IN EMACS                             
==========================================================================

bin/cm is a console app that can be used as an inferior scheme process
in Emacs.  Add this snippet to your .emacs file and fix 'cm-path' for
your machine. Then restart emacs and start CM by doing: M-x: cm

;-----------------------------------------------------------------------

(defvar cm-path "~/Software/cm/") ; FIX pathname for your machine
(require 'scheme)
(load (concat cm-path "res/etc/sal.el"))
(let ((spec '("definstrument" "loop" "process" "run" "send")))
  (font-lock-add-keywords 'scheme-mode
    (list (cons (concat "(" (regexp-opt spec t) "\\>") 1))))
(defun cm (path)
  "Start CM"
  (interactive (list (if prefix-arg
			 (read-string "Command to start CM: " "cm") 
		       (concat cm-path "bin/cm"))))
  (run-scheme path))


==========================================================================
                                SVN ACCESS                                
==========================================================================

svn co http://commonmusic.svn.sourceforge.net/svnroot/commonmusic/trunk cm

==========================================================================
                                DEVELOPING                                
==========================================================================

To build against the juce debug libs:

    $ make CONFIG=Debug

To build universal:

    $ make CONFIG=Release TARGET_ARCH="-arch i386 -arch ppc"


To create the embedded Scheme runtime sources:

    $ juce_bb scm src SchemeSources

To create the embedded instruments:

    $ juce_bb res/ins src/ Instruments

    To ADD instruments do this first:
      1. Copy the instrument file(s) to res/ins/files.
      2. Edit res/ins/table.xml and rows for the new files.
      3. Create the zip archive and generate the resource:
         $ zip -r files.zip files/*.scm files/*.clm 

To create the embedded documetation

    $ juce_bb res/doc src/ Documentation

To create the other Resources:

    $ juce_bb res/font src/ Fonts
    $ juce_bb res/images src/ Images

To generate FFI files (requires a working 'format'...):

  (load "/Users/hkt/Software/cm/scm/genffi.scm")
  (s7ffi "/Users/hkt/Software/cm/src/SndLibBridge.cpp")
  (chickenffi "/Users/hkt/Software/cm/scm/chicken-foreign.scm")

To regenerate ChickenBridge.cpp:

    $ cd scm
    $ csc -c++ -embedded -t ChickenBridge.scm
    $ mv ChickenBridge.cpp ../src

==========================================================================
                                  PORTING                                
==========================================================================

The implementation file for each Scheme (s7.scm, Chicken.scm) defines
implementation features that are either not provided or unevenly
provided in scheme implementations. Here is the list of features that
must be in effect after that file is loaded:

(define-macro a b)
(define-for-syntax a b)
(define-record name . slots)
(define-constant a b)
(error str . args)
(format stream fstring . args)
(when test . forms)
(unless test . forms)
(logand i . ints)
(logior i . ints)
(logxor i . ints)
(lognot i)
(ash a i)
(fixnum? n)
most-positive-fixnum
most-negative-fixnum
pi
(object->string x)
(string->keyword s)
(keyword->string k)
(make-equal-hash-table )
(hash-ref tab key )
(hash-set! tab key val)
(random int)
(list-set! l i v)
(format #t "~A~S~%" ...)
(void) 
(read-from-string str)
(sort! lst . pred)
(sort  lst . pred)
(interaction-environment)
(error-protected-process-code timevar waitvar
			      stopping looping stepping )

