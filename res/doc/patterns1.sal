;
; Patterns

; Patterns are objects that generate data in different ways. cycle is
; the simplest type of pattern, it generates its data in an endless
; loop from front to back. to use a pattern you first have to make it:

define variable pat = make-cycle( {a b c d } )

; once you have a pattern use the next function to read data from it.
; execute this statement a number of times to see what is printed

print next(pat)

; Use note key or hz to convert data into notes keynums or hertz
; values before you put them in pattern. Remember that octave numbers
; are sticky in note lists:

define variable pat = make-cycle( note( {a4 b c5 d e}) )

; calling next with #t reads a whole "period" or "chunk" of elements
; from the pattern:

print next(pat, #t)

define variable pat = make-cycle( key( {a4 b c5 d e}))

print next(pat, #t)

define variable pat = make-cycle( hz( {a4 b c5 d e}))

print next(pat, #t)

define variable pat = make-cycle( note( {a b c5 d e}))

; for simple streams, if the second argument is a number then a list
; of that many elements are returned from the pattern

print next(pat, 3)

; the for: parameter lets you specify a "period size" for the stream
; when you create it

define variable pat = make-cycle( note( {a4 b c5 d e}), for: 3)

; the period length of this pattern is different than the number of
; elements it contains.

print next(pat, #t)

; remember that for: is a named parameter so you can specify it
; positionally as well:

define variable pat = make-cycle( note( {a4 b c5 d e}), 3)

print next(pat, #t)

; Important pattern rule: Constant data can be replaced by patterns of
; data. So we can replace the number 3 with a pattern of period
; lengths

define variable pat =
  make-cycle( {a b c d}, for: make-cycle( {2 3 4 5} ))

loop repeat 8
  print next(pat, #t)
  end

; Since we can replace constant data with patterns, we can create
; subpatterns of data. in this example we put a heap pattern inside a
; cycle pattern. A <heap> randomly shuffles its data.

define variable pat =
  make-cycle(list(make-cycle({a1 a2 a3}),
                  make-cycle({b1 b2 b3}),
                  make-cycle({c1 c2 c3})))

print next(pat, #t)

define variable pat =
  make-cycle(list(make-cycle({a1 a2 a3}, for: 1),
                  make-cycle({b1 b2 b3}, for: 1),
                  make-cycle({c1 c2 c3}, for: 1)))

print next(pat, #t)

; a heap pattern generates its data in random order by shuffling it each time it starts over:

define variable pat = make-heap( note( {a4 b c5 d e} ))

print next(pat, #t)

;; TODO: create a cycle of heaps and a heap of cycles and listen to
;; the difference



;; you can stick a pattern at any point in the data specified to
;; another pattern

define variable
  pat = make-cycle( list*( make-heap( {a4 a5 a6}, 1), {b4 c5 d e}))
                  
loop 
  repeat 5 print next(pat, #t) 
end
                                    
; a palindrome generates items forwards and backwards

define variable pat = make-palindrome( {a b c d e} )

print next(pat, #t)

; use the elide argument to enable/disable direct repetition of the
; terminal values

define variable pat = make-palindrome( {a b c d e}, elide: #t)

print next(pat, #t) 

; to elide just the beginning or the end of the pattern specify a list
; of two values:

define variable pat = make-palindrome( {a b c d e}, elide: {#t #f})

print next(pat, #t) 

define variable pat = make-palindrome( {a b c d e}, elide: {#f #t})

print next(pat, #t) 

; a line sticks on the last element in the pattern

define variable pat = make-line( {a b c d e} )

print next(pat, #t)

define variable pat = 
  make-line( list(1, 2, 3, make-heap( {a b c d})))

print next(pat, #t)

; a weighting performs discrete random selection, by default all
; values have an equal likelyhood of being selected:

define variable pat = make-weighting( {a b c d})

print next(pat, #t)

;; to provide more (or less) weight for a given item specify it as a
;; list together with its weight {item weight}

define variable pat = make-weighting( {{a 3} b c d})

print next(pat, 20)

define variable pat = make-weighting( {{a 3}{b 10} c d})

print next(pat, 20)

; a min value specifies how many times it must be directly selected

define variable pat = make-weighting({a {b 1 2} c d})

print next(pat, 20)

; a max value specifies max times it might be directly selected

define variable pat = make-weighting({a {b 1 1 2} c d})

print next(pat, 20)

; working with patterns. you can make functions to return them

define function mypat(notes)
  return make-cycle( list(make-heap( notes ),
                          make-heap( transpose( notes, 12)),
                          make-heap( transpose( notes, -12))
                          ))

define variable pat = mypat( note({a4 b c5 d e}) )

print next(pat, 20)

define process playpat (num, notes, rate)
  run with zztop = mypat(notes)
    repeat num
    for n = next(zztop)
    send "mp:midi", dur: rate * 2, key: key(n), amp: .7
    wait rate
  end

sprout playpat(30, note({a4 b c5 d e}), .2)
    
; Designing patterns

; TODO: create mypat2 that is like mypat but it take a list of
; intervals and a list of transpostion offsets and return a cycle
; containing as many heaps as offsets with each heap containing the
; intervals tranposed to the offset

; TODO: design a pattern that randomly returns quarters, eighth s and
; triplets. if eights are selected then 2 must be returned, if
; triplets are picked then three must be returned. no more than 2
; quarters can be consecutively returned.


; here is a little example that generates randomly constructed chords

define function makechords ()
 return make-cycle( list( make-heap( note({c6 d ef f g a bf}),
                                     make-weighting( {3 4 5})) ,
                          make-heap( note( {c5 d ef f g a bf}),
                                    make-weighting({3 4 5})) ,
                          make-heap( note( {c4 d ef f g a bf}),
                                    make-weighting( {3 4 5}))
                                   ),
                   for: 1)

define function makerhythms()
  return make-cycle({1 1 1 .5})

define variable pat = makechords()

print next(pat, #t)

define function in-tempo(r,t)
  return (r * (60 / t))

define process playjazzchords(num, notepat, rhypat, tpo)
  run repeat num
    for rhy = in-tempo( next(rhypat), tpo)
    for chd = next(notepat, #t)
    loop for n in chd
      send "mp:midi", key: key(n), dur: .1, amp: .8
    end
    wait rhy
  end

sprout playjazzchords(30, makechords(), makerhythms(), 160)


