;;; **********************************************************************
;;; Copyright (C) 2008 Rick Taube
;;; This program is free software; you can redistribute it and/or   
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************
;;; $Revision: 1206 $
;;; $Date: 2007-02-01 09:44:18 -0600 (Thu, 01 Feb 2007) $

; (sal "load \"~/404A/sal/test.sal\"")

(require-extension posix)

(define (date-and-time)
  (time->string (seconds->local-time (current-seconds))))

(define (pathname-directory s)
  (let ((l (string-length s)))
    (do ((i (- l 1) (- i 1)))
	((or (< i 0) (char=? (string-ref s i) #\/))
	 (if (< i 0) #f (substring s 0 (+ i 1)))))))

(define (pathname-name s)
  (let ((l (string-length s)))
    (do ((i (- l 1) (- i 1))
	 (x #f))
	((or (< i 0) (char=? (string-ref s i) #\/))
	 ;; dont confuse /.foo with /foo.
	 (if (and x (> (- x i) 1)) (set! l x))
	 (substring s (+ i 1) l))
      (if (and (not x) (char=? (string-ref s i) #\.))
	  (set! x i)))))

; (pathname-name "foo.bar")
; (pathname-name "foo/bar.baz")
; (pathname-name ".baz")
; (pathname-name "baz")

(define (pathname-type s)
  (let ((l (string-length s)))
    (do ((i (- l 1) (- i 1))
	 (x #f))
	((or (< i 0) x)
	 (cond ((not x)	#f)
	       ((= x 0) #f)
	       ((char=? (string-ref s (- x 1)) #\/)
		#f)
	       (else
		(substring s (+ x 1) l))))
      (if (char=? (string-ref s i) #\.)
	  (set! x i)
	  (if (char=? (string-ref s i) #\/)
	      (set! i -1))))))

; (pathname-type "foo.bar")
; (pathname-type "/foo.bar")
; (pathname-type ".bar")
; (pathname-type "/.bar")
; (pathname-type "./bar")

(define (make-pathname . args)
  (define (new-pathname d)
    (if (not d) 
	(list #:directory "" #:name "" #:type "")
	(list #:directory (or (pathname-directory d) "")
	      #:name (or (pathname-name d) "")
	      #:type (or (pathname-type d) ""))))
  (let* ((def (member #:defaults args))
	 (nam (member #:name args))
	 (typ (member #:type args))
	 (dir (member #:directory args))
	 (new (new-pathname (if def (cadr def) #f))))
    (if dir (set-car! (cdr (member #:directory new)) (cadr dir)))
    (if nam (set-car! (cdr (member #:name new)) (cadr nam)))
    (if typ (set-car! (cdr (member #:type new)) (cadr typ)))
    (do ((path "")
	 (tail new (cddr tail)))
	((null? tail) path)
      (if (eq? (car tail) #:type)
	  (set! path (string-append path "." (cadr tail)))
	  (set! path (string-append path (cadr tail)))))))

; (make-pathname #:name "foo" #:type "html" #:defaults "/fpo/haha.tid")

;;;
;;; stoh routines
;;;

(define-macro (getchar x s)
 `(begin (set! ,x (read-char ,s))
	 (if (eof-object? ,x) 
	     (begin
	       ;; reached eof on .sal file
	       (format out "</pre>~%")
	       (return-from-read #:eof)
	       ))))

(define (begspan out type)
  (format out "<span class=\"~A\">"
	  (keyword->string type)))

(define (endspan out . eol )
  (format out "</span>")
  (if (not (null? eol)) (newline out)))

(define-macro (cpwhite ch in ou bo)
  `(do ((+whites+ '(#\space #\tab #\return #\newline)))
       ((not (member ,ch +whites+)) #f)
     (write-char ,ch ,ou)
     (if (eq? ,ch #\newline) (set! ,bo #t)
	 (set! ,bo #f))
     (getchar ,ch ,in)))

(define (salhtmlheader out source-url)
  (format out "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"
\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">
<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">
<head>
<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\"/>
<style type=\"text/css\" media=\"all\">
span.string  {color: #bc8f8f;} 
span.output  {color: #bc8f8f;} 
span.comment {color: #b22222;}  
span.keyword {color: #da70d6;} 
span.reserved {color: #a020f0;}
span.classof {color: #228b22;}
span.command {color: #0000ff;}
span.constant {color: #5f9ea0;}
pre.salcode{}
</style>
<title>~A.html</title>
</head>
<body>
"
	  ;; pre.salcode{background: #f7f7f7;}
	  (pathname-name source-url)
	  )
  (format out "<p><span style=\"font-size:large;\">Download source: ")
  (format out "<a href=~S>
<img src=\"fileicon.png\" style=\"border:none;\" alt=\"[fileicon.png]\" /> ~A.~A</a>"
	  source-url
	  (pathname-name source-url)
	  (pathname-type source-url))
  (format out "</span></p>~%<hr/>"))

(define (salhtmlfooter out file)
  (format out "<hr/>~%<div style=\"float:left;\"><p>Generated by <em>sal2html</em> ~A</p></div><div style=\"float:right;\"><a href=\"http://validator.w3.org/check?uri=referer\"><img src=\"http://www.w3.org/Icons/valid-xhtml10-blue\" style=\"border:none;\" alt=\"Valid XHTML 1.0 Strict\" height=\"31\" width=\"88\"/></a></div>~%</body>~%</html>~%"
	  (date-and-time)))

(define tokentypes 
  `((#:classof "variable" "function" "process"
	      , (lambda (s l)
		  (and (char=? (string-ref s 0) #\<)
		       (char=? (string-ref s (- l 1)) #\>)))
		)
   (#:keyword , (lambda (s l)
		  (char=? (string-ref s (- l 1)) #\:)))
   (#:reserved
    "begin" "chdir" "define" "exec" "if" "load" "loop"
    "print" "set" "send" "sprout"
    "run" "return" "unless" "wait" "when" "with"
    "above" "below" "by" "downto" "else"
    "end"  "finally" "for" "from" "in" "repeat"
    "then" "to" "unless" "until" "wait" "when" "while" "with")
    ))

(define (toktype str len bol)
  (call/cc
   (lambda (return-from-toktype)
     (for-each (lambda (l)
		 (for-each (lambda (x)
			     (if (string? x)
				 (if (string=? str x) 
				     (return-from-toktype (car l)))
				 (if ( x str len)
				     (return-from-toktype (car l))))
			     )
			   (cdr l)))
	       tokentypes)
     #f)))

; (toktype "finally" 7 #t)
; (toktype "kokoko:" 7 #t)
; (toktype "process" 7 #t)

(define (htmlwritechar c out)
  (cond ((char=? c #\<) (format out "&lt;"))
	((char=? c #\>) (format out "&gt;"))
	((char=? c #\&) (format out "&amp;"))
	(else (write-char c out))))
	 
(define (htmlwritestring str out . args)
  (let ((len (if (null? args) (string-length str) (car args))))
    (do ((i 0 (+ i 1)))
	((= i len) #f)
      (htmlwritechar (string-ref str i) out))))

(define (colorizetok out str len bol)
  (let ((type (toktype str len bol)))
    (if (eq? type #:reserved)
	(if bol (set! type #:command)))
    (if type (begspan out type))
    (htmlwritestring str out len)
    (if type (endspan out))))
		   
(define STDOUT (current-output-port))

(define (stoh-loop sal out)
  (lambda (return-from-read)
    (do ((bol #t)
	 (chr #f)
	 (len #f)
	 (+delims+ '(#\" #\' #\# #\, #\; #\{ #\} #\[ #\] 
		     #\( #\) #\space #\tab #\return #\newline))
	 (str (make-string 256)))
	(#f #f)
      (getchar chr sal)
      ;; copy all white chars to output
      (cpwhite chr sal out bol)
      ;; chr now non-white char, possibly at bol
      ;;(format STDOUT "char ~S~%" chr)
      (cond ((char=? chr #\;)
	     (begspan out #:comment)
	     (do ()
		 ((char=? chr #\newline) #f)
	       (htmlwritechar chr out)
	       (getchar chr sal))
	     (endspan out #t)
	     (set! bol #t))
	    ((char=? chr #\")
	     (begspan out #:string)
	     (do ((x #f))
		 (x #f)
	       (htmlwritechar chr out)			  
	       (getchar chr sal)
	       (if (char=? chr #\") (set! x #t)))
	     (htmlwritechar chr out)
	     (endspan out)
	     (set! bol #f))
	    ((char=? chr #\#)
	     (begspan out #:constant)
	     (htmlwritechar chr out)
	     (getchar chr sal)
	     (htmlwritechar chr out)
	     (endspan out)
	     (set! bol #f))
	    (else
	     ;; gobble token to next delim, which may be chr
	     (set! len 0)
	     (do ()
		 ((member chr +delims+)
		  #f)
	       (string-set! str len chr)
	       (getchar chr sal)
	       (set! len (+ len 1)))
	     (if (> len 0)
		 (colorizetok out (substring str 0 len)
			      len bol))
	     ;; write delimiter
	     (htmlwritechar chr out)
	     (if (member chr '(#\return #\newline))
		 (set! bol #t)
		 (set! bol #f)))))))  
 
(define (sal2html file . args)
  (let ((html #f)
	(source-url #f)
	(out #f)
	(sal #f))
    (cond ((pair? args)
	   (set! html (cadr args))
	   (if (pair? (cdr args))
	       (set! source-url (caddr args))
	       (set! source-url file)))
	  (else
	   (set! html (make-pathname #:type "html" #:defaults file))
	   (set! source-url file)))
    (with-input-from-file file
      (lambda ()
	(set! sal (current-input-port))
	(if (file-exists? html) (delete-file html))
	(with-output-to-file html
	  (lambda ()
	    (set! out (current-output-port))
	    (salhtmlheader out (make-pathname #:name (pathname-name file)
					      #:type (pathname-type file)
					      #:defaults source-url))
	    (format out "<pre class=\"salcode\">~%")
	    (call/cc (stoh-loop sal out) )
	    (format out "</pre>~%")
	    (salhtmlfooter out file)
	    ))
	html))))

; (load "/Lisp/grace/doc/stoh.scm")
; (sal2html "/Lisp/grace/doc/examples/continuum.sal")
; (make-pathname #:directory "/Lisp/grace/doc/examples/"  #:defaults "continuum.sal")

#|
(let ((d "/Lisp/grace/doc/examples/"))
  (do ((l (directory d) (cdr l)))
      ((null? l) #t)
    (let ((x (pathname-type (car l)))
	  )
      (if (equal? x "sal")
	  (let ((p (make-pathname #:directory d #:defaults (car l))))
	    (format #t "~%~S" p)
	    (sal2html p))))))
|#







