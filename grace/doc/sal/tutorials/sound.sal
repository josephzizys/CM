;
;; Sound Output
;

; The sound you generate in Common Music can be sent to files, ports,
; or graphic displays. For the next few lessons we will learn how to
; generate sound to MIDI (.mid) files for playback, lilypond (.ly)
; files for notation using FOMUS, and MusicXML (.xml) files for
; importing into Finale/Sibelius.

;
;; Files, Directories and Pathnames
;

; You can refer to files and directories (folders) in the code you
; write using a specially formatted string called a
; 'pathname'. Pathnames have the format:

; "/directory/.../file.ext"

; where everything up to the last / are called 'directory components',
; followed by the 'file name', and ending with the 'file extension'
; after the dot.  For example, in this pathname:
; "/Users/hkt/test.mid", the directory components are "/Users/hkt/",
; the file name is "test" and the file extension is "mid". Of course
; pathnames can also consist of just the file parts: "test.mid", or
; just the directory components: "/Users/hkt/".

; Each directory component separated by / is located under the
; previous directory.  So "/Users/hkt/" refers to the "hkt" folder
; inside the "Users" folder on the hard drive.  Pathnames that start
; with "/" as the first character are called 'absolute pathnames':
; they describe a pathname from the very top of your computer's hard
; drive (the initial /).  Relative pathnames (pathnames that don't
; start with /) are also possible. The most common relative pathname
; is the shortcut "~/" that stands for to your 'home directory'. This
; lets you specify files under your personal account without having to
; know where the account is located on the machine. For example, for
; me (hkt) "~/" points to "/Users/hkt/" on my office and home machines
; and to "/Network/Servers/camilx2.music.uiuc.edu/Users/Faculty/hkt"
; when I am logged into a CAMIL machine.

; A word of caution: avoid using spaces or other special characters
; when you create new files or folders in the Finder: non-alphanumeric
; characters can cause problems when you work with pathname strings!

;
;; The 'working directory'
;

; If a pathname contains just the file name and extension, for
; example: "test.mid", then CM will use its current 'working
; directory' as the directory for the file.  The working directory is
; automatically set to your home directory whn you start Common
; Music. You can see what the current working directory is at any time
; by printing the pathname returned by the 'pwd' function, or by using
; the "Current Directory" item in the SAL menu.

; print the working directory:

print pwd()

; remember that the print command does not show surrounding "" in the
; strings it displays so you will not see the pathname's string quotes
; in the print message.

;
;; the 'chdir' command
;

; You can change your working directory using 'chdir', or by using
; "Set Directory..."  in the SAL menu. In this next example we change
; the working directory to your personal class directory under your
; home folder:

chdir "/tmp"

print pwd()

; Now change back to your home directory:

chdir "~/"

print pwd()

;
;; The 'open' command (creating and customizing musical streams)
;

; Common Music establishes connections to sound destinations like
; files, ports and external applications using an object called a
; 'stream'. A stream holds information about the destination you will
; be sending your sound to and it allows you to customize this
; information to create exactly the type of sound you want. Use the
; 'open' command to create a file stream. Here is how to open a stream
; to a MIDI file called "test.mid" in the current working directory:

open "test.mid"

; Before we can output sound to "test.mid" we need something to make
; the sound.  The next example defines a little algorithmic process
; that just generates random midi notes between a lower and upper
; keynum bound. We will discuss the 'define' command in great detail
; in a week or two, for now simply evaluate the command by placing
; your cursor after the word 'end' and pressing Enter:

define process simp(num, rate, dur, lowkey, hikey, amp, chan)
  run repeat num
    output make(<midi>, time: now(),
                duration: dur,
                keynum: between(lowkey,hikey) ,
                amplitude: amp,
                channel: chan)
    wait rate
  end

;
;; The 'sprout' command
;

; At this point we have opened an output stream to the file "test.mid"
; and defined an algorithmic process named 'simp'. Let's generate some
; sound!  Use the 'sprout' command to trigger algorithmic output to
; the open musical stream. Evaluate this next command and listen to
; the result.  Then evaluate it again and listen. Do this several
; times.

sprout simp(16, .25, .5, 60, 70, .3, 0)

; Now try this one. Use your ears to determine what sound parameters
;  the various input values control!

sprout simp(8, .5, .25, 20, 30, .7, 0)

; Experiment with the next example, trying our different input values.
; the first input value (the 'num' parameter to 'simp') is the number
; of notes the process creates. the second input (rate) is the amount
; of time (in beats) the process waits between sending a note. the
; third value (dur) is the amount of time (in beats) that each note
; lasts. the fourth and fifth parameters (lowkey and hikey) are the
; bounds for random key number selection. MIDI key numbers must be
; betweeen 0 < 128, where 60 is middle C.  The last value (amp) is the
; relative amplitude of the note where 0.0 is silence and 1.0 is as as
; loud as possible.

sprout simp(16, .25, .5, 60, 70, .3, 0)

;
;; the 'play' command
;

; use the 'play' command to play an existing file WITHOUT genereating
; it first. You can also use "Play file..." in the SAL menu.

play "test.mid"

;
;; Sprouting more that one process at a time
;

; You can sprout more than one process at the same time by passing it
; a LIST of all the processs to sprout. In this next example we will
; sprout two copies of simp, each with their own musical
; characterisics. Put your cursor just after the last ) and press
; Enter:

sprout list(  simp(16, .2, .4, 60, 70, .3, 0) ,
              simp(8, .4, .1, 20, 30, .7, 0)
              )

; Note that the , at the end of the first line is the delimiter that
; separates the two simps in the list that is passed to sprout.

;; sprouting with different time offsets

; the 'sprout' command also accepts an optional time offset argument
; that can hold a LIST of start time offsets to spread over the
; multiple processes. Here we will sprout 5 simps at prime number
; rates , each offset by one 4/4 measure:

sprout list(  simp( 20 * 2, 1/2, 1/2, 36, 48, .5, 0) ,
              simp( 16 * 3, 1/3, 1/3, 48, 60, .5, 0) ,
              simp( 12 * 5, 1/5, 1/5, 60, 72, .5, 0) ,
              simp(  8 * 7, 1/7, 1/7, 72, 84, .5, 0) ,
              simp(  4 * 11, 1/11, 1/11, 84, 96, .5, 0)
              ) , 
       {0 4 8 12 16}

;
;; Customizing MIDI streams with 'open'.
;

; Each type of stream has a set of features that you can
; customize. For example, all MIDI files have a 'tempo' factor that
; you can set. The default tempo is 60, to generate events with some
; other tempo use the tempo: parameter when you open the stream.  This
; next example reopens our "test.mid" stream with the tempo two times
; faster:

open "test.mid", tempo: 120

sprout simp(16, .25, .5, 60, 70, .3, 0)

; Notice also that setting the tempo parameter is 'sticky': its new
; value remains in effect until you execute open again with a
; different tempo: value.  try out a few other tempi!

open "test.mid", tempo: 20

sprout simp(8, .25, .125, 60, 70, .3, 0)

; Perhaps you have noticed that each time you call sprout, the
; contents of "test.mid" is created afresh. This means that any
; previous vesion of the file will be overwritten unless you rename
; that older version before you execute the next sprout. One way to
; avoid this potential problem is to use the the 'versioning:'
; parameter available for all file streams. If this parameter is
; turned on then sprout will automatically append a number to the
; file's name each time it is written, thus avoiding overwriting of
; the same file name durring the same session. To turn versioning on
; specify #t (boolean true) to the parameter. To turn it off specify
; #f (boolean false):

open "test.mid", tempo: 60, versioning: #t

; now sprout several simps and notice that the file names are called
; test-1.mid, test-2.mid, test-3.mid, and so on:

sprout simp(16, .25, .125, 60, 70, .3, 0)

;
;; Working with FOMUS (algorithmic music notation)
;

; FOMUS, developed by David Psenicka at UIUC, is a software package
; that can translate algoritmically generated music into Common
; Practice notation.  FOMUS can output to Lilypond Music Notation, or
; to Finale/Sibelius via the MusicXML markup language that is becoming
; the defacto standard for importing/exporting musical notation 


;
;;  'system' command.
;

; Before you can work with FOMUS notational output you must first load
; the software system into the Lisp runtime system. Use SAL's 'system'
; command or choose Systems>Fomus from the SAL menu:

system "fomus"

; Once Fomus is loaded use the 'open' command to open a FOMUS
; stream. The first kind of stream we will work with generates .ly
; input file for the Lilypond notation program:

open "test.ly", versioning: #t 

sprout simp(32, 1/4, 1/4, 40, 70, .3, 0)

; the play: init will generate a .mid file of the notated score:


open "test.ly", play: #t

sprout simp(32, 1/4, 1/4, 40, 70, .3, 0)

; You can use FOMUS parts objects to organize music into logical score
; units. You create a part using the make(...)  function. There are
; two essential part initializations that you should always set:

; instr: sets the part's instrument name (self-evaluating symbol)
; partid: sets the part's score identifier (integer). In MIDI data the
; channel values are paired with partid's to determine which part the
; notes belong to here we define two parts that make up a violin and a
; cello duo:

define variable duet = list( make( <part>, instr: :violin, partid: 1),
                             make( <part>, instr: :cello, partid: 2))

; You pass parts to the score when you open it:

open "duet.ly", parts: duet

; now we generate two different lines with simp, the MIDI channel
; value 2 in the first voice sends it to the cello part (partid 2) and
; channel value 1 in the second voice sends it to the violin part
; (partid 1):

sprout list( simp(20, 2/5, 2/5, 36, 70, .3, 2),
             simp(32, 1/4, 1/4, 55, 96, .3, 1) )

;
;; Working with Finale and Sibelius
; 

; Use the FOMUS .xml file to generate notations for Finale or
; Sibulius. After you generate the file, start Finale and use the
; Import command to load the XLM file. WARNING: XLM support in Finale
; and Sibelius is somewhat spotty, Sibelius' is particularly poor.

open "duet.xml", parts: duet

sprout list( simp(16, 1/2, 1/2, 36, 70, .3, 2),
             simp(32, 1/4, 1/4, 55, 96, .3, 1) )

; for more information about FOMUS see: fomus.sal, micro.sal and the
; Fomus documentation.

