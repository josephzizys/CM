; A SAL program consists of comments, commands and symbolic
; expressions. Comments are ignored by SAL. They begin with a
; semi-colon and last until the end of the line:

; this is a comment

; A command is a statement that gets executed to accomplish a task.
; Commands expressions start in the first column and their command
; names appear in blue.  Here's a simple first example using the
; 'print' command. Put the cursor at the end of the command line and
; press COMMAND-Enter. Then look in the console window for the
; associated output. Lisp must be running in order to execute a
; command.

print "Hello, world!"

; You can command help by placing your cursor on a command word and
; pressing the Help key on the Mac or F1 on Linux or Windows. Try
; accessing help on the preceding print command...

; A symbolic expression is something that produces a value for a
; command to use. This next print command is spread over two lines and
; contains two clauses: the first clause is a function call that picks
; a word at random, the second clause contains the second word of the
; message. Note that the comma is used to connect command and function
; arguments when there is more than one of them. Put the cursor at the
; end of the secnod line and press COMMAND-Enter several times to see
; what happens:

print odds(.6, "Hello", "Goodbye"), 
      " world!"

; if you notice that you are pressing COMMAND-Enter a bunch of times,
; consider using a loop. Put your cursor just after the 'end' and
; press Command-Enter:

loop repeat 10
  print odds(.6, "Hello", "Goodbye"), " world!"
end
 
; any construct that concludes with the word 'end' is called a 'code
; block'. code blocks can declare local variables and contain more
; than one statement:

begin
  with key = between(60,90) ,
       amp = random(128)
  print "my random amp is ", amp
  print "my random keynum is ", key
end

; Here is an example of defining a musical algorithm, also a code
; block. Put the cursor just after the word 'end' and press
; COMMAND-Enter to define the process:

define process piano-phase (length, keys, tempo)
  run 
    with pat = make(<cycle>, of: keys)
    until now() >= length
    output make(<midi>, time: now(), keynum: next(pat), duration: tempo)
    wait tempo
  end

; this next block declares two local variables and then opens a midi
; file and runs two copies of our piano-phase algorithm. Place the
; cursor just after the word 'end' and execute the command to hear
; what it does:

begin 
  with notes = {e4 fs4 b4 cs5 d5 fs4 e4 cs5 b4 fs4 d5 cs5},
       length = 20
  open "reich.mid"
  sprout list(piano-phase (length, notes, .166),
              piano-phase (length, notes, .17))
end

; shuffle the trope to compose differnt versions of the piece each
; time we press COMMAND-Enter. since we are not sure what we will be
; hearing, we save different versions of the piece so we can choose
; the one we like the best:

begin 
  with notes = shuffle( {e4 fs4 b4 cs5 d5 fs4 e4 cs5 b4 fs4 d5 cs5}),
       length = 20
  open "reich.mid", versioning: #t
  sprout list(piano-phase (length, notes, .166),
              piano-phase (length, notes, .17))
end


