;
;; Defining Functions
;

; Your compositional work will require you to design and implement new
; functions to accomplish musical tasks. We have already learned how
; to use them (by calling them with input values) but we don't know
; anything about how they are actually implemented.

; Recall that a function works by receiving arguments (input values)
; in its parameters, which are special variables in which it receives
; the data you pass it. The function then executes uses these
; parmeters its internal code (statements) that calculate a result
; that it returns back to you as the 'value' of the function call.
; The statements that the function executes are called the 'body' of
; the function: this is where the work happens. Any SAL statement can
; be used as the function's body, including the special 'return'
; statement that returns a value back to the caller. If the function
; requires more than one statement use a 'begin...end' statement as
; the function's body and then sequence as many statements as
; necessary inside the blocl. A begin...end can also be used to
; declare local local variables inside the function, if needed.

;; The 'define function' command

; Use the 'define function' command to create a new function. The
; command requires three pieces of information: (1) the name of the
; new function, (2) what input parameters it will take (if any) and
; (3) the SAL statement the function will execute when it is
; called. Here is a first example of a function definition. The
; function is called 'knum->pc' because it converts an input keynum
; 0-127 into a pitch class 0-11. The function declares one input
; parameter (knum) and the statement the function executes is the
; special 'return' statement that can appear inside a function
; definition to return a value back to the caller. The pitch class that
; our function calculates and returns is simply mod 12 of the input
; keynum.

; Put the cursor at the end of the second line and press COMMAND-Enter
; to execute the definition:

define function key->pc (k)
  return k % 12

print key->pc(60)

print key->pc(59)

; Note that although a function's body consists of only one statement,
; that statement can be a 'begin...end' block, which means that they
; can execute any number of statements.  Here is a (not very useful)
; function that executes two print statements when you call it. Note
; that this function does NOT have a return statement. Functions that
; do not explicitly return a value return an unspecified value back to
; the caller.

define function knum-info (knum)
  begin
    print "my key number is ", knum
    print "my pitch class is ", key->pc(knum)
  end

print knum-info( random(128))

; Notice that our little function has two print statments but three
; lines are printed! the third line is the #f (boolean false) returned
; by the function (since it did not have a return statement) -- this
; third line is the value that the print command itself prints

; This next little function demonstrates how to declare more than one
; parameter. It performs the opposite calculation of the first
; function: it returns a key givein a pc and a octave offset. The
; function declares two parameters: pc is the pitch class and octace is
; the keynum offset. 

define function pc->key (pc, oct)
  return pc + (12 * (oct + 1))

; note that the function adds 1 to the octave so that the middle-c
; octave number 4 produces key number 60...

print pc->key(0, 4)

; it is very common for functions to call other functions to do some of the work. here we define

define function pc->note(pc, oct)
  begin with k = pc->key(pc, oct)
    return note(k)
  end

print pc->note(0, 4)

print pc->note(6, 2)

print pc->note( random(12), between(2,8))

;
;; Predicate functions and conditional statements
;

; A 'predicate' is a function that returns true or false based on a
; test of its argument(s). Preicates often use what are called
; 'conditional statements' to accomplish their tasks.  The 'if then
; else' statement is the most flexble conditional: it consists of
; three parts: a test is first evaluated, if the test is true (not #f)
; then a 'then' statement is executed, otherwise an optional 'else'
; statement is executed. Here is the definition of a predicate
; function that returns true if its input key number is a black key,
; otherwise it returns false. Notice that the 'true' value that the
; function returns is the pitch class of the black key rather than
; boolean true. Since boolean logic says that any value that is not #f
; must, by definition, be true, the true value can be anything that is
; not stricly #f!  This is qute handy and allows our function to
; return useful information (the pitch class) when the key in question
; is actually a black key:

define function black-key? (knum)
  begin
    with pc = key->pc(knum)
    if member( pc, {1 3 6 9 10}) then
      return pc
    else return #f
  end

begin
  with k = random(128)
  print "key: ", k, " is black: ", black-key?(k)
end

; Notice that, in the case of our last example, the then and the else
; clauses both execute a return statement. these clauses differ only
; in the value that is returned, not by the statements themselves. In
; a case like this is possible to use a single return statemnt that
; returns a conditional value. Recall that the conditional value is
; notated #?  (test, true, false) where test, true and false are all
; sexprs. If the test is true then the true value is used, otherwise
; the else value is used. Here is another, perhaps clearer, way to
; write the function:

define function black-key? (knum)
  begin
    with pc = key->pc(knum),
         sw = member( pc, {1 3 6 9 10}) 
    return #?( sw , pc, #f)
  end
