;
;; Defining Functions
;

; Your compositional work will require you to design and implement new
; functions to accomplish musical tasks.  Up to now we have treated
; functions as "black boxes": we know how use them (by calling them
; with input values) but we don't know anything about how they are
; actually implemented.

; A function works by first receiving input values in its parameters
; (the "windows" through which it receives values) then executing
; statements that use those values to calculate a result, and then
; returning that result back to the caller. (You can think about a
; function's parameters as local variables inside the function that
; are automatically initialized to the values you pass to the function
; each time you call it).  The statement that the function executes is
; called the 'body' of the function: this is where the work
; happens. Any SAL statement can be used as the function's body,
; including the special 'return' statement (it can only appear inside
; a funcion defintion) that returns a value back to the caller. If the
; function needs to execute more than one statement use a
; 'begin...end' statement as the function's body and then sequence as
; many statements as necessary inside it. THe beging...end can also be
; used to declare local local variables, if needed.

;; the 'define function' command

; Use the 'define function' command to create a new function. The
; command requires three pieces of information: (1) the name of the
; new function, (2) what input parameters it will take (if any) and
; (3) the SAL statement the function will execute when it is
; called. Here is a first example of a function definition. The
; function is called 'knum->pc' because it converts an input keynum
; 0-127 into a pitch class 0-11. The function declares one input
; parameter (knum) and the statement the function executes is the
; special 'return' statement that can appear inside a function
; definition to return a value back to the caller. The pitch class that
; our function calculates and returns is simply mod 12 of the input
; keynum.

; Put the cursor at the end of the second line and press Enter to
; execute the definition:

define function keynum->pc (knum)
  return knum % 12

print keynum->pc(60)

print keynum->pc(59)


; Although a function's definition consists of only one statement,
; that statement can be a 'begin...end' block, which means that
; functions can really execute any number of statements.  Here is a
; (not very useful) function that executes two print statements when
; you call it. Note that this function does not have a return
; statement. If a function does not contain a return statement then it
; will still execute its statements but it will always return #f
; (boolean false) back to the caller.

define function knum-info (knum)
  begin
    print "my key number is ", knum
    print "my pitch class is ", keynum->pc(knum)
  end

print knum-info( random(128))

; notice that our little function has two print statments but three
; lines are printed! the third line is the #f (boolean false) returned
; by the function (because it did not have a return statement) and is
; printed by the print command that called the function

; this next little function demonstrates how to declare more than one
; parameter. It performs the opposite calculation of the first
; function: it returns a keynum givein a pc and a keynum offset. The
; function declares two parameters: pc is the pitch class and koff is
; the keynum offset.

define function pc->keynum (pc, koff)
  return pc + koff

print pc->keynum(1, 60)

print pc->keynum(6, 72)

; It is very common for functions to call other functions to do part
; of their work.  Our next function definition transposes a pc to a
; specified octave number. It uses the pc->keynum function we just
; defined to do the actual work. A the begin...end block is used to
; define a local variable 'k', the key number transposition offset
; calculated from the input octave number and passed into pc->keynum
; to do the work:

define function pc->oct (pc, oct)
  begin
    with k = 12 * (oct + 1)   ; oct->keynum, ie 4->60
    return pc->keynum(pc, k)
  end

print pc->oct(0, 4)

print pc->oct(11, 3)

;
;; predicate functions and conditional statements
;

; predicate functions are functions that return true or false based on
; a test of their input argument(s). this sort of function often uses
; conditional statements to accomplish their tasks.  then 'if then
; else' statement performs conditional execution: a test sexpr is
; first evaluated, if the sexpr returns true (that is, not #f) a
; 'then' statement is executed, otherwise an optional 'else' statement
; is executed. Here is a predicate function definition that returns
; true if its input key number is a black key, otherwise it returns
; false. Notice that the 'true' value that the function returns is the
; pitch class of the black key rather than boolean true. Since any
; value that is not #f must be true, this function returns potentially
; useful information (the pitch class) when the key in question is
; actually a black key:

define function black-key? (knum)
  begin
    with pc = keynum->pc(knum)
    if member( pc, {1 3 6 9 10}) then
      return pc
    else return #f
  end

print black-key?( random(128))

; Notice that, in the case of our last example, the then and the else
; clauses both execute a return statement. these clauses differ only
; in the value that is returned, not by the statements themselves. In
; a case like this is possible to use a single return statemnt that
; returns a conditional value. Recall that the conditional value is
; notated #?  (test, true, false) where test, true and false are all
; sexprs. If the test is true then the true value is used, otherwise
; the else value is used. Here is another, perhaps clearer, way to
; write the function:

define function black-key? (knum)
  begin
    with pc = keynum->pc(knum),
         sw = member( pc, {1 3 6 9 10}) 
    return #?( sw , pc, #f)
  end
