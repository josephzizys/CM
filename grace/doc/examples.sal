;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Working with lists

;; a 10 element list
print make-list( 10)

;; a list filled with zeros

print make-list(10, 0)

;; a list with 10 random numbers 0-1
print make-list(10, ran)

;; a list of 10 random numbers 0-10.0
print make-list(10, ran, 10.0)

;; a list of 10 integers between 60 and 90
print make-list(10, between, 60, 90)

;; a list of 10 pinkish values (-1 to 1)
print make-list(10, ranpink)

;; a list of 10 pinkish keys between 60 and 90
print rescale( make-list(10, ranpink), -1, 1, 60, 90)

;; a list of 10 pinkish int keys between 60 and 90
print discrete( make-list(10, ranpink), -1, 1, 60, 90)

;; summing 10 random numbers 0-10.0
print plus( make-list(10, ran, 10.0))

;; a list of 10 random numbers quantized to .25
print quantize( make-list(10, ran, 10.0) .25)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Note, key and pc

;; note quantizes to quarter tone resolution
print note( 60.1)

print note( 60.6)

;; note key pc and hz all accept lists of data
print note( make-list(10, between, 60.0, 80.0))

;; lowest octave is 00 highest is 9
print note( {0 127})

;; octave numbers are sticky in note lists
print key( {c4 d e f g a b c5 d e f g a b c6} )

;; a list of 10 pinkish notes beween 60 and 90
print note( make-list(10, ranpink), -1, 1, 60, 90)

;; a list of 10 pinkish pitch classes 
print pc( discrete( make-list(10, ranpink), -1, 1, 60, 90))

;; transpose and invert work with notes, keys and pcs
print transpose( {c4 e g}, 12)

print transpose(7, 7)

print invert( {c4 e g} )

print invert(11)

;; marix generator
loop with mat = {},
          row = shuffle( {0 1 2 3 4 5 6 7 8 9 10 11})
  for i in invert(row)
  set mat &= transpose(row, i)
  finally print mat
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Scales and interval cycles

print scale(16, 60, 2, 1, 2, 2, 1, 2, 2)

;; octatonic with just whole and half steps
print scale(16, 60, 2.04, 1.12)

;; scale goes either direction
print scale(16, 60, -2, -1, -2, -2, -1, -2, -2)

;; does not assume octave repetiion
print scale(16, 60, 2, 1, 2, 1, 1)

;; scale accepts lists of intervals
print scale(16, 60, {1 2 3})

;; can give it a boundary for wrapping
print note( scale(24, 60, {7 1 7 -1} 84) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; A Markov harmonizer

;; a 1st order markov pattern generates steps between chord tones

define variable mark
  make-markov( {{1 -> {1 .25} {2 2} {3 .5} {4 .4} {5 .3} {6 .1}}
                {2 -> {3 1} {4 .5} {5 .3} {6 .2}}
                {3 -> {1 .2} {2 1} {4 .5} {5 .3 {6 .2}}}
                {4 -> {1 .2} {2 1} {3 .4} {4 .3} {6 .2}}
                {5 -> {1 1} {2 1} {3 .5} {4 .5} {5 .5} {6 .5}}
                {6 -> {1 1} {2 1} {3 .5} {4 .5} {5 .5} )

;; try it out 

begin with n = 5
  print note( scale( n, 60, next(mark, n - 1)))
end

;; define a player for chords

define function playchord( ch, d, a)
  loop for c in ch
    send "mp:midi" key: c dur: d amp: a
   end

;; try out the player

begin with n = 5
  exec playchord( scale( n, 60, next( mark, n - 1)),
                  1, .7)
end

;; define a midi hook. The louder the note the more chord tones are
;; added

define function chordhook(mm)
  if mm:on?( mm) then
    begin 
      with n = int( interp( mm:vel( mm), 20, 2, 100, 6))
      ;; the louder we play the more notes are added
      exec playchord( scale(n, mm:key( mm),
                            next(mark, n - 1))
                      .5
                      mm:vel(mm))
    end

;; Set the inhook. First make sure to turn off active senseing on the
;; Midi In port!

send "mp:inhook", chordhook

;; clear the hook when you are done

send "mp:inhook", #f

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Musial Processes

define process pinkscale(len, scale)
  run repeat len
    send "mp:midi", key: discrete( ranpink(), -1, 1, scale)
    wait .125
  end

define variable dorian = scale(50, 20, 2, 1, 2, 2, 2, 1, 2)

sprout pinkscale(60, dorian)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Using ids to selectively stop processes

define process chopin (n, r, d, k)
  run repeat n
    send "mp:midi", dur: d, key: k
    wait r
  end

;; sprout D# minor chord with ids

begin
  sprout chopin(50, .5, .25, 63), 0, 1
  sprout chopin(50, .5, .25, 66), 0, 2
  sprout chopin(50, .5, .25, 70), 0, 3
  sprout chopin(50, .5, .25, 75), 0, 1
end

;; first stop F#, then A# then the D# octave

exec stop(2)
exec stop(3)
exec stop(1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Pentatonic wind chimes with amp envelope and exponential decay

define process chimes(n)
  run with l = {0 2 5 7 9 12}, k = 37 + (12 * ran(5))
    for i below n
    send "mp:midi", 0, between( 2.0, 4.0),
         k + nth( l, ran( 6)),
         interp(i, 0, 90, n, 30)
    wait rescale( i, 0, n, .1, between(1.5, 2.0), 50)
  end

sprout chimes( 20 )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Triggering real-time processes via a MIDI input hook

define process playscale(key, dur)
  run with scl = odds(.5, scale(15, key, 2, 2, 1, 2, 2, 2, 1),
                      scale(17, key, 2, 1)), 
           len = length(scl)
    for i below len
    send "mp:midi", key: nth( scl, i),
         dur: .5,
         amp: interp( i, 0, .9, len, .5)
    wait dur / len
  end

;; test the process
  
sprout playscale( 60, 1.2)

;; define a hook to play a scale based on a key you press...

define function myhook (m)
  if mm:on?(m) then
    begin with k = mm:key(m)
      sprout playscale(k, 1.2)
    end

;; set hook ...

send "mp:inhook", myhook

;; now play your MIDI keyboard ...  then clear your hook when done

send "mp:inhook", #f

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sending to the Csound port

define process ranins1(len, rhy, lb, ub, amp)
  run with dur = rhy * 2
    repeat len
    for key = lb then ran(lb,ub)
    send "cs:i", 1, 0, dur, key, amp
    wait rhy
  end

sprout ranins1(10, .2, 60, 72, 1000)

